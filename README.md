glyphNotes • ALL‑IN‑ONE Agent + Weights + Checkpoints + Container
Storage: No · GGUFs: 0
Bind storage
Run Setup
Diagnostics
Agent
Autopilot
Deploy
Setup
Code
Chat
Maestro
PyWeights
Chat
Volumes
Weights
Checkpoints
Container
Self‑Update
Storage
Journal
Settings
Active GGUFs: 0
Agent
Builds websites / scaffolds into GSC2 capsules, stores as volumes, auto‑executes, and can spill heavy payloads to container.

e.g., Build a website name=Atlas with blog, contact, dashboard
Activate & Glyph
Website
Self‑Test
Live Preview

'; const js=const App=(()=>{const routes={"/":()=>Home(),"/about":()=>About()${spec.blog?',"/blog":()=>Blog()':''}${spec.contact?',"/contact":()=>Contact()':''}${spec.dashboard?',"/dashboard":()=>Dashboard()':''}${spec.auth?',"/auth":()=>Auth()':''}};function mount(p){const el=document.getElementById('app');el.innerHTML=(routes[p]||NotFound)();if(window.afterRoute)window.afterRoute(p)}function navigate(e,p){e&&e.preventDefault();history.pushState(null,'',p);mount(p)}window.addEventListener('popstate',()=>mount(location.pathname));window.addEventListener('DOMContentLoaded',()=>mount(location.pathname||'/'));window.navTo=(p)=>navigate(null,p);function Home(){return + "" + 
${spec.name}
Generated by glyphNotes ALL‑IN‑ONE

 + "" + }function About(){return + "" + 
About
${spec.name}
 + "" + }function NotFound(){return + "" + 
404
 + "" + }${spec.contact?function Contact(){return + "" +   Contact   Your name   Email   Your message   Send   + "" + }window.afterRoute=(p)=>{if(p==='/contact'){const f=document.getElementById('contactForm');f.onsubmit=async(e)=>{e.preventDefault();const data=Object.fromEntries(new FormData(f).entries());const out=document.getElementById('contactOut');out.style.display='block';out.textContent='Preview payload:\n'+JSON.stringify(data,null,2);}}};:''}${spec.blog?function Blog(){return + "" +   Blog   + "" + }window.afterRoute=(p)=>{if(p==='/blog'){const wrap=document.getElementById('posts');wrap.innerHTML=[{id:'hello',title:'Hello',excerpt:'Generated post.'}].map(p=> + "" + `
${p.title}
${p.excerpt}

 + "" + ).join('');}};:''}${spec.dashboard?function Dashboard(){const n=64,data=Array.from({length:n},(_,i)=>({x:i,y:Math.sin(i/6)+Math.random()*0.1}));return + "" + 
Dashboard
Sample: ${JSON.stringify(data.slice(0,8))}
 + "" + }window.afterRoute=(p)=>{if(p==='/dashboard'){const c=document.getElementById('chart').getContext('2d');const w=c.canvas.width,h=c.canvas.height;c.clearRect(0,0,w,h);c.beginPath();c.moveTo(0,h/2);c.lineWidth=2;const n=64;for(let i=0;i   Account   Signed in. Sign out    + "" + : + "" +   Sign in   Email   Password   Sign in   + "" + ;}:''}return{mount,navigate}})();; return [ {name:"index.html", data:strToU8(index)}, {name:"assets/style.css", data:strToU8(css)}, {name:"assets/app.js", data:strToU8(js)}, ];} function findFile(files, prefix){ return files.find(f=>f.name===prefix) || files.find(f=>f.name.endsWith('/'+prefix)) || null; } async function previewWebsiteFromFiles(files){ const idx = findFile(files, 'index.html'); if(!idx){ return; } const css = findFile(files, 'assets/style.css'); const js = findFile(files, 'assets/app.js'); let html = u8ToStr(idx.data); if(css){ const cssText = u8ToStr(css.data); html = html.replace(/]+href=["']/?assets/style.css["'][^>]>/i, ); } if(js){ const jsText = u8ToStr(js.data); html = html.replace(/]+src=["']\/?assets\/app\.js["'][^>]*><\/script>/i, ); } $('#preview').srcdoc = html; } // ===== Execute unified glyphs ===== async function executeUnifiedGlyph(unifiedBytes){ try{ const files = tarRead(unifiedBytes); const mf = files.find(f=>/manifest.json$/.test(f.name)); if(!mf) return; const manifest = JSON.parse(u8ToStr(mf.data)); const pfile = files.find(f=>/^payload_..tar$/.test(f.name)); if(!pfile){ return; } const payloadFiles = tarRead(pfile.data); if(manifest.route==='web' || /payload_web.tar$/.test(pfile.name)){ await previewWebsiteFromFiles(payloadFiles); return; } // default: download payload saveBlob(${manifest.name}_payload.tar, new Blob([pfile.data], {type:'application/x-tar'})); }catch(e){ /* swallow / } } // ===== Volumes UI ===== async function refreshVolumesUI(){ const wrap=$('#volumes'); wrap.innerHTML=''; const vols=await GlyphFS.list(); if(vols.length===0){ wrap.textContent='No volumes yet.'; return; } for(const name of vols){ const row=document.createElement('div'); row.className='card'; const text=await GlyphFS.load(name); const title=document.createElement('div'); title.innerHTML=${name}; const btns=document.createElement('div'); btns.style.marginTop='.5rem'; const bRun=document.createElement('button'); bRun.textContent='Run (auto‑exec)'; bRun.onclick=async()=>{ try{ const dec=await decodeCapsule(text, $('#setVerify').checked); await executeUnifiedGlyph(dec.bytes); }catch(e){ alert('Run failed: '+e.message); } }; const bExp=document.createElement('button'); bExp.textContent='Export .gvol'; bExp.onclick=async()=>{ const bl=await GlyphFS.exportVolume(name); saveBlob(${name}.gvol, bl); }; const bDel=document.createElement('button'); bDel.textContent='Delete'; bDel.onclick=async()=>{ await GlyphFS.remove(name); await refreshVolumesUI(); }; const bPrev=document.createElement('button'); bPrev.textContent='Preview capsule'; bPrev.onclick=async()=>{ const pre=document.createElement('pre'); pre.textContent=text.slice(0,1200)+(text.length>1200?'...\n':''); row.appendChild(pre); }; btns.append(bRun, document.createTextNode(' '), bExp, document.createTextNode(' '), bDel, document.createTextNode(' '), bPrev); row.append(title, btns); wrap.appendChild(row); }} // ===== WeightGlyph DB & runner ===== const WGDB = (()=>{ const DB='wgdb_allin1'; function open(){ return new Promise(res=>{ const r=indexedDB.open(DB,2); r.onupgradeneeded=()=>{ const d=r.result; ['models','tensors','chunks','meta','stubs'].forEach(s=>{ if(!d.objectStoreNames.contains(s)) d.createObjectStore(s); }); }; r.onsuccess=()=>res(r.result); }); } async function put(store, key, value){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).put(value,key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); } async function get(store, key){ const db=await open(); return new Promise((res)=>{ const tx=db.transaction(store,'readonly'); const rq=tx.objectStore(store).get(key); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>res(null); }); } async function del(store, key){ const db=await open(); return new Promise((res)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key); tx.oncomplete=()=>res(); tx.onerror=()=>res(); }); } async function keys(store){ const db=await open(); return new Promise(res=>{ const tx=db.transaction(store,'readonly'); const os=tx.objectStore(store); const out=[]; os.openCursor().onsuccess=e=>{ const c=e.target.result; if(c){ out.push(c.key); c.continue(); } else res(out); }; }); } return {put, get, del, keys}; })(); async function wgIndexFromCapsuleText(text){ const dec = await decodeCapsule(text, $('#setVerify').checked); const files = tarRead(dec.bytes); const mf = files.find(f=>/wg_manifest.json$/.test(f.name)) || files.find(f=>/manifest.json$/.test(f.name)); if(!mf) throw new Error('wg_manifest.json not found'); const manifest = JSON.parse(u8ToStr(mf.data)); const modelId = manifest.model_id || await sha256(strToU8((manifest.model_name||'model') + JSON.stringify(manifest.tensors||[]))); const tensors = manifest.tensors || []; for(const t of tensors){ let data=null; const tf = files.find(f=>f.name===t.path || f.name.endsWith('/'+(t.path||''))); if(tf){ data=tf.data; } else { const df = files.find(f=>/data.bin$/.test(f.name)); if(!df) throw new Error('tensor data missing'); data = df.data.subarray(t.offset||0, (t.offset||0)+(t.length_bytes||0)); } const hash = await sha256(data); await WGDB.put('chunks', hash, data); await WGDB.put('tensors', ${modelId}:${t.name}, { sha256: hash, dtype: t.dtype, shape: t.shape, bytes: data.byteLength }); await WGDB.put('meta', chunk:${hash}, { bytes: data.byteLength, last: Date.now(), ckpt: null }); } await WGDB.put('models', modelId, { id:modelId, name: manifest.model_name||('Model_'+modelId.slice(0,8)), entry: manifest.entry, tensors: tensors.map(x=>x.name) }); await addJournal({type:'wg.index', model: modelId, tensors: tensors.length}); return {id:modelId, tensors: tensors.length}; } async function wgListModels(){ const ids = await WGDB.keys('models'); const out=[]; for(const id of ids){ out.push(await WGDB.get('models', id)); } return out; } async function wgChunkCount(){ const keys = await WGDB.keys('chunks'); return keys.length; } async function wgModelChunks(modelId){ const model = await WGDB.get('models', modelId); if(!model) return []; const out=[]; for(const name of (model.tensors||[])){ const meta=await WGDB.get('tensors', ${modelId}:${name}); if(meta) out.push(meta.sha256); } return Array.from(new Set(out)); } async function wgGetTensor(modelId, name){ const meta = await WGDB.get('tensors', ${modelId}:${name}); if(!meta) throw new Error('tensor meta missing'); let data = await WGDB.get('chunks', meta.sha256); if(!data){ const stub = await WGDB.get('stubs', meta.sha256); if(stub){ throw new Error(Chunk is evicted. Restore checkpoint: ${stub.ckpt}); } throw new Error('tensor bytes missing'); } const m=await WGDB.get('meta', chunk:${meta.sha256}) || {bytes:0,last:0,ckpt:null}; m.last=Date.now(); await WGDB.put('meta', chunk:${meta.sha256}, m); return {meta, data: new Uint8Array(data)}; } // CPU MLP function f16ToF32(u16){ const out=new Float32Array(u16.length); for(let i=0;i>15; let e=(h&0x7C00)>>10; let f=h&0x03FF; if(e===0){ out[i]= (s?-1:1) * Math.pow(2,-14) * (f/Math.pow(2,10)); } else if(e===31){ out[i]= f?NaN: ((s?-1:1)Infinity); } else { out[i]= (s?-1:1) * Math.pow(2,e-15) * (1 + f/Math.pow(2,10)); } } return out; } async function runMLP_CPU(modelId, inputVec){ const model = await WGDB.get('models', modelId); const entry = model.entry || {type:'mlp', layers:['W1','b1','W2','b2']}; const {meta:mw1, data:W1} = await wgGetTensor(modelId, entry.layers[0]); const {meta:mb1, data:b1} = await wgGetTensor(modelId, entry.layers[1]); const {meta:mw2, data:W2} = await wgGetTensor(modelId, entry.layers[2]); const {meta:mb2, data:b2} = await wgGetTensor(modelId, entry.layers[3]); const [inDim, hidDim] = mw1.shape; const [hidDim2, outDim] = mw2.shape; const W1f = f16ToF32(new Uint16Array(W1.buffer, W1.byteOffset, W1.byteLength/2)); const b1f = f16ToF32(new Uint16Array(b1.buffer, b1.byteOffset, b1.byteLength/2)); const W2f = f16ToF32(new Uint16Array(W2.buffer, W2.byteOffset, W2.byteLength/2)); const b2f = f16ToF32(new Uint16Array(b2.buffer, b2.byteOffset, b2.byteLength/2)); const x = new Float32Array(inDim); for(let i=0;i>31)&1; let exp=(x>>23)&0xFF; let mant=x&0x7FFFFF; let h=0; if (exp === 0) h = (sign<<15); else if (exp === 0xFF) h = (sign<<15) | 0x7C00 | (mant?0x200:0); else { const newExp = exp - 127 + 15; if (newExp >= 0x1F) h = (sign<<15) | 0x7C00; else if (newExp <= 0) { if (newExp < -10) h = (sign<<15); else { mant = (mant | 0x800000) >> (1 - newExp); h = (sign<<15) | (mant >> 13); } } else { h = (sign<<15) | (newExp<<10) | (mant >> 13); } } out[i]=h; } return out; } function randF32(n, scale=0.1){ const a=new Float32Array(n); for(let i=0;iset.add(h)); } return Array.from(set); } async function bucketizeLRU(targetBytes){ const keys = await WGDB.keys('meta'); const entries=[]; for(const k of keys){ if(!k.startsWith('chunk:')) continue; const m = await WGDB.get('meta', k); const hash=k.split(':')[1]; const have = await WGDB.get('chunks', hash); if(!have) continue; entries.push({hash, bytes:m.bytes||0, last:m.last||0}); } entries.sort((a,b)=> (a.last||0)-(b.last||0)); const sel=[]; let total=0; for(const e of entries){ if(total>=targetBytes) break; sel.push(e.hash); total+=e.bytes; } return {hashes:sel, total}; } async function buildCheckpointTar(name, hashes){ const files=[]; const chunksMeta=[]; for(const h of hashes){ const data = await WGDB.get('chunks', h); if(!data) continue; const bytes = new Uint8Array(data); files.push({name:chunks/${h}.bin, data: bytes}); const m = await WGDB.get('meta', chunk:${h}) || {bytes:bytes.byteLength, last:Date.now(), ckpt:null}; chunksMeta.push({sha256:h, bytes: bytes.byteLength, last: m.last||0}); } const ckpt = { version:1, type:'weight-checkpoint', name, created_at:nowISO(), chunks:chunksMeta }; files.unshift({name:'ckpt_manifest.json', data: strToU8(JSON.stringify(ckpt, null, 2))}); const tar = tarPack(files); const unified = tarPack([{name:'manifest.json', data: strToU8(JSON.stringify({version:2, route:'ckpt', name}, null, 2))}, {name:'payload_ckpt.tar', data: tar}]); return unified; } async function exportCheckpoint(name, hashes, evict){ const unified = await buildCheckpointTar(name, hashes); const capsule = await encodeCapsuleGSC2(unified, {kind:'checkpoint', name:CKPT_${name}}); const blob = new Blob([capsule], {type:'text/plain'}); saveBlob(CKPT_${name}.gvol, blob); for(const h of hashes){ await WGDB.put('stubs', h, { ckpt:CKPT_${name}, time: Date.now() }); if(evict){ await WGDB.del('chunks', h); } } return {capsuleLen: capsule.length, hashes: hashes.length}; } async function restoreCheckpointFromText(text){ const dec = await decodeCapsule(text, $('#setVerify').checked); const files = tarRead(dec.bytes); const p = files.find(f=>/payload_ckpt.tar$/.test(f.name)); const payload = p ? tarRead(p.data) : files; const mf = payload.find(f=>/ckpt_manifest.json$/.test(f.name)); if(!mf) throw new Error('ckpt_manifest.json missing'); const ckpt = JSON.parse(u8ToStr(mf.data)); let restored=0; for(const f of payload){ const m = f.name.match(/^chunks/([0-9a-f]{64}).bin$/); if(!m) continue; const h=m[1]; await WGDB.put('chunks', h, f.data); await WGDB.del('stubs', h); const meta = await WGDB.get('meta', chunk:${h}) || {bytes:f.data.byteLength, last:Date.now(), ckpt:null}; await WGDB.put('meta', chunk:${h}, {...meta, bytes:f.data.byteLength}); restored++; } return {name: ckpt.name, restored}; } // ===== Container Bridge (File System Access API) ===== const Bridge = (()=>{ const DB='container_handles_allin1'; function open(){ return new Promise(res=>{ const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{ const d=r.result; if(!d.objectStoreNames.contains('handles')) d.createObjectStore('handles'); }; r.onsuccess=()=>res(r.result); }); } async function saveHandle(key, handle){ const db=await open(); return new Promise((res,rej)=>{ const tx=db.transaction('handles','readwrite'); tx.objectStore('handles').put(handle, key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); } async function loadHandle(key){ const db=await open(); return new Promise(res=>{ const tx=db.transaction('handles','readonly'); const rq=tx.objectStore('handles').get(key); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>res(null); }); } async function persist(){ if(!('storage' in navigator) || !navigator.storage.persist) return null; return await navigator.storage.persist(); } async function persisted(){ if(!('storage' in navigator) || !navigator.storage.persisted) return null; return await navigator.storage.persisted(); } async function pickContainer(){ if(!('showDirectoryPicker' in window)) throw new Error('File System Access API not available (Chromium + HTTPS/localhost).'); const dir = await window.showDirectoryPicker({ mode: 'readwrite' }); await saveHandle('container', dir); return dir; } async function getContainer(){ return await loadHandle('container'); } async function ensureDirs(dir, parts){ let cur = dir; for(const part of parts){ cur = await cur.getDirectoryHandle(part, { create:true }); } return cur; } async function writeFile(relPath, bytes){ const dir = await getContainer(); if(!dir) throw new Error('No container bound'); const parts = relPath.split('/').filter(Boolean); const fname = parts.pop(); const parent = await ensureDirs(dir, parts); const fh = await parent.getFileHandle(fname, { create:true }); const ws = await fh.createWritable(); await ws.write(bytes); await ws.close(); return true; } async function readFile(relPath){ const dir = await getContainer(); if(!dir) throw new Error('No container bound'); const parts = relPath.split('/').filter(Boolean); const fname = parts.pop(); let cur = dir; for(const p of parts){ cur = await cur.getDirectoryHandle(p); } const fh = await cur.getFileHandle(fname); const file = await fh.getFile(); return new Uint8Array(await file.arrayBuffer()); } async function listRecursive(prefix=''){ const dir = await getContainer(); if(!dir) throw new Error('No container bound'); const out=[]; async function walk(handle, path){ for await (const [name, entry] of handle.entries()){ if(entry.kind==='directory') await walk(entry, path + name + '/'); else out.push(path+name); } } let start = dir; if(prefix){ const parts = prefix.split('/').filter(Boolean); for(const p of parts){ start = await start.getDirectoryHandle(p); } } await walk(start, prefix||''); return out; } return { pickContainer, getContainer, writeFile, readFile, listRecursive, persist, persisted }; })(); async function fetchToContainer(url, relPath){ const res = await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const u8 = new Uint8Array(await res.arrayBuffer()); await Bridge.writeFile(relPath, u8); const sha = await sha256(u8); return { bytes: u8.byteLength, sha }; } async function scanAndIndex(){ const list = await Bridge.listRecursive('capsules').catch(()=>[]); const index = { created_at: nowISO(), items: [] }; for(const p of list){ try{ const buf = await Bridge.readFile(p); const text = u8ToStr(buf); const head = text.trim().split(/\r?\n/)[0]||''; let kind='unknown'; if(head.includes('GSC2')) kind='gsc2'; else if(head.includes('GSC1')) kind='gsc1'; else if(/^⟡GSC/.test(text)) kind='one-line'; let meta={}; if(kind==='gsc2'){ try{ meta = JSON.parse(text.split(/\r?\n/)[1]||'{}'); }catch{} } index.items.push({ path: p, kind, name: meta.name||'unknown', type: meta.kind||'unified' }); }catch(e){} } await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify(index, null, 2))); return index; } // ===== Storage monitor ===== async function estimateQuota(){ if(!('storage' in navigator) || !navigator.storage.estimate) return null; const est = await navigator.storage.estimate(); return {usage: est.usage||0, quota: est.quota||0}; } // ===== Experience Weights (system_xp) ===== async function xpEmit(kind, payload){ try{ const j = JSON.stringify({kind, payload, t: nowISO()}, null, 2); const bytes = strToU8(j); const sha = await sha256(bytes); // Store chunk bytes (they're small) and a tensor record await WGDB.put('chunks', sha, bytes); const modelId = 'system_xp'; let m = await WGDB.get('models', modelId); if(!m){ m = {id:modelId, name:'System Experience', entry:{type:'xp'}, tensors:[]}; await WGDB.put('models', modelId, m); } const tname = 'xp_' + Date.now(); await WGDB.put('tensors', ${modelId}:${tname}, { sha256: sha, dtype: 'json', shape: [bytes.byteLength], bytes: bytes.byteLength }); m.tensors.push(tname); await WGDB.put('models', modelId, m); }catch(e){ / ignore / } } async function xpList(){ const m = await WGDB.get('models', 'system_xp'); if(!m) return []; const out=[]; for(const tname of m.tensors){ const meta = await WGDB.get('tensors', ${m.id}:${tname}); const data = await WGDB.get('chunks', meta.sha256); if(data){ out.push(JSON.parse(u8ToStr(new Uint8Array(data)))); } } return out; } // ===== GGUF integration (blob-level, container-backed) ===== async function integrateGGUFBytes(u8, opts={name:'model.gguf', savePath:'weights/gguf/model.gguf', toContainer:true}){ const sha = await sha256(u8); // If container desired, write there & register stub; otherwise store bytes (small files) or deny if too big let location = null; if(opts.toContainer){ try{ await Bridge.writeFile(opts.savePath, u8); location = 'container://' + opts.savePath; }catch(e){ // fallback: if can't write, store in IndexedDB (warn for large files) location = '(embedded)'; await WGDB.put('chunks', sha, u8); } } else { if(u8.byteLength <= 12810241024){ // 128MB safeguard await WGDB.put('chunks', sha, u8); location = '(embedded)'; } else { throw new Error('Refusing to embed >128MB without container. Bind a container or enable "save to container".'); } } // Register a model entry const modelId = 'gguf_' + sha.slice(0,12); const tname = 'gguf_bytes'; await WGDB.put('tensors', ${modelId}:${tname}, { sha256: sha, dtype: 'bytes', shape: [u8.byteLength], bytes: u8.byteLength }); await WGDB.put('models', modelId, { id:modelId, name: opts.name || ('GGUF '+sha.slice(0,8)), entry:{type:'gguf-blob', path: location}, tensors:[tname] }); // Place a stub pointing to the container location (if used) if(location && location.startsWith('container://')){ await WGDB.put('stubs', sha, { ckpt: location, time: Date.now() }); } await xpEmit('gguf.integrate', { modelId, bytes: u8.byteLength, location }); return {modelId, sha, location}; } async function handleSelfUpdateURL(url, saveAs, toContainer){ const res = await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const u8 = new Uint8Array(await res.arrayBuffer()); const lower = (url.split('?')[0]||'').toLowerCase(); if(lower.endsWith('.pyweights') || lower.endsWith('.py')){ const name = (url.split('/').pop()||'model.pyweights').replace(/[^A-Za-z0-9_.-]/g,''); const path = saveAs || ('weights/pyweights/'+name); const text = new TextDecoder().decode(u8); const out = await integratePyWeightsText(name, text, toContainer, path); return {type:'pyweights', ...out}; } else if(lower.endsWith('.pyweights') || lower.endsWith('.py')){ const name = (file.name||'model.pyweights').replace(/[^A-Za-z0-9.-]/g,''); const path = saveAs || ('weights/pyweights/'+name); const text = await file.text(); const out = await integratePyWeightsText(name, text, toContainer, path); return {type:'pyweights', ...out}; } else if(lower.endsWith('.gvol')){ const text = new TextDecoder().decode(u8); await GlyphFS.save((saveAs||'update').replace(/[^A-Za-z0-9.-]/g,''), text); await wgIndexFromCapsuleText(text).catch(()=>{}); // index if it’s a weights capsule if(toContainer){ await Bridge.writeFile(saveAs||('capsules/'+(url.split('/').pop()||'update.gvol')), u8); } await xpEmit('selfupdate.gvol.url', { url, saveAs }); return {type:'gvol', bytes: u8.byteLength}; }else if(lower.endsWith('.gguf')){ const name = (url.split('/').pop()||'model.gguf').replace(/[^A-Za-z0-9.-]/g,''); const path = saveAs || ('weights/gguf/'+name); const out = await integrateGGUFBytes(u8, {name, savePath:path, toContainer}); return {type:'gguf', ...out}; }else if(lower.endsWith('.html')){ // Save new app build into container updates/ and offer download const name = (url.split('/').pop()||'index.html').replace(/[^A-Za-z0-9.-]/g,''); const path = saveAs || ('updates/'+name); if(toContainer){ await Bridge.writeFile(path, u8); } const blob = new Blob([u8], {type:'text/html'}); saveBlob(name, blob); await xpEmit('selfupdate.html.url', { url, saveAs:path }); return {type:'html', bytes: u8.byteLength, path}; }else{ // Generic store const name = (url.split('/').pop()||'file.bin').replace(/[^A-Za-z0-9.-]/g,''); const path = saveAs || ('files/'+name); if(toContainer){ await Bridge.writeFile(path, u8); } await xpEmit('selfupdate.generic.url', { url, saveAs:path, bytes: u8.byteLength }); return {type:'file', bytes: u8.byteLength, path}; } } async function handleSelfUpdateFile(file, saveAs, toContainer){ const u8 = new Uint8Array(await file.arrayBuffer()); const name = (file.name||'upload.bin').replace(/[^A-Za-z0-9.-]/g,''); const lower = name.toLowerCase(); if(lower.endsWith('.pyweights') || lower.endsWith('.py')){ const name = (url.split('/').pop()||'model.pyweights').replace(/[^A-Za-z0-9.-]/g,''); const path = saveAs || ('weights/pyweights/'+name); const text = new TextDecoder().decode(u8); const out = await integratePyWeightsText(name, text, toContainer, path); return {type:'pyweights', ...out}; } else if(lower.endsWith('.pyweights') || lower.endsWith('.py')){ const name = (file.name||'model.pyweights').replace(/[^A-Za-z0-9.-]/g,''); const path = saveAs || ('weights/pyweights/'+name); const text = await file.text(); const out = await integratePyWeightsText(name, text, toContainer, path); return {type:'pyweights', ...out}; } else if(lower.endsWith('.gvol')){ const text = await file.text(); await GlyphFS.save((name||'update').replace(/[^A-Za-z0-9.-]/g,''), text); await wgIndexFromCapsuleText(text).catch(()=>{}); if(toContainer){ await Bridge.writeFile(saveAs || ('capsules/'+name), strToU8(text)); } await xpEmit('selfupdate.gvol.file', { name, saveAs }); return {type:'gvol', bytes: u8.byteLength}; }else if(lower.endsWith('.gguf')){ const path = saveAs || ('weights/gguf/'+name); const out = await integrateGGUFBytes(u8, {name, savePath:path, toContainer}); return {type:'gguf', ...out}; }else if(lower.endsWith('.html')){ const path = saveAs || ('updates/'+name); if(toContainer){ await Bridge.writeFile(path, u8); } const blob = new Blob([u8], {type:'text/html'}); saveBlob(name, blob); await xpEmit('selfupdate.html.file', { name, saveAs:path }); return {type:'html', bytes: u8.byteLength, path}; }else{ const path = saveAs || ('files/'+name); if(toContainer){ await Bridge.writeFile(path, u8); } await xpEmit('selfupdate.generic.file', { name, saveAs:path, bytes: u8.byteLength }); return {type:'file', bytes: u8.byteLength, path}; } } // ===== Chat (voice + actions) ===== const Chat = (()=>{ let recog=null, listening=false; const supportsSTT = ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window); function ensureRecog(){ if(!supportsSTT) return null; const Ctor = window.SpeechRecognition || window.webkitSpeechRecognition; if(!recog){ recog=new Ctor(); recog.lang='en-US'; recog.interimResults=false; recog.continuous=false; } return recog; } function speak(text){ try{ if(!(document.getElementById('chatSpeak')||{checked:(localStorage.getItem('chatSpeakOn')!=='0')}).checked) return; if(!('speechSynthesis' in window)) return; const u=new SpeechSynthesisUtterance(text.replace(/<[^>]+>/g,'')); u.rate=1; u.pitch=1; u.volume=1; speechSynthesis.speak(u); }catch(e){ /* ignore */ } } function add(role, text){ const box=$('#chatBox'); const row=document.createElement('div'); row.className='chat-msg ' + (role==='user'?'chat-user':'chat-bot'); const bub=document.createElement('div'); bub.className='bubble'; bub.innerText = text; row.appendChild(bub); box.appendChild(row); box.scrollTop = box.scrollHeight; } async function handle(text){ add('user', text); await xpEmit('chat.user', {text}); const low = text.toLowerCase(); // Routing: website generation if((/build|make|create/).test(low) && /website|site|webapp/.test(low)){ add('bot','On it — generating a website capsule…'); await autoGlyph(text); add('bot','Website capsule generated and previewed. You can find it in Volumes.'); speak('Website generated.'); return; } // PyWeights import via URL in message if(/pyweights|.py\b/.test(low)){ const urlMatch = text.match(/https?://\S+/); if(urlMatch){ const url=urlMatch[0]; try{ add('bot','Fetching PyWeights…'); const res = await handleSelfUpdateURL(url, 'weights/pyweights/'+(url.split('/').pop()||'model.pyweights'), true); add('bot', PyWeights integrated: ${JSON.stringify(res)}); speak('Pyweights integrated.'); }catch(e){ add('bot','Error: '+e.message); speak('Error importing pyweights.'); } return; } } // GGUF import via URL in message const urlMatch = text.match(/https?://\S+/); if(/gguf/.test(low) && urlMatch){ const url=urlMatch[0]; const toContainer = true; const saveAs = 'weights/gguf/' + (url.split('/').pop()||'model.gguf').replace(/[^A-Za-z0-9.-]/g,''); try{ add('bot', 'Fetching GGUF → Container…'); const res = await handleSelfUpdateURL(url, saveAs, toContainer); add('bot', GGUF integrated: model=${res.modelId} bytes=${res.bytes||res.size||'?'}); speak('GGUF integrated.'); }catch(e){ add('bot', 'Error: '+e.message); speak('Error on GGUF integration.'); } return; } // GVOL import via URL if(/gvol/.test(low) && urlMatch){ const url=urlMatch[0]; try{ add('bot','Fetching .gvol…'); const res = await handleSelfUpdateURL(url, '', true); add('bot', Imported capsule: type=${res.type}); speak('Capsule imported.'); }catch(e){ add('bot','Error: '+e.message); speak('Error importing capsule.'); } return; } // Bind container if(/bind container|upgrade storage|pick directory/.test(low)){ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); add('bot', Container bound to: ${dir.name}); speak('Container bound.'); }catch(e){ add('bot', 'Bind failed: '+e.message); speak('Binding failed.'); } return; } // Load demo weight if(/load demo weight|demo weight|demo mlp/.test(low)){ const id = await createDemoWeightGlyph(); add('bot', Demo MLP ready: ${id}); speak('Demo weights loaded.'); return; } // Run model (first one) if(/run model|run mlp|inference/.test(low)){ const models = await wgListModels(); if(models.length===0){ add('bot','No models indexed yet. Load demo or import weights.'); speak('No models yet.'); return; } let vec=new Array(16).fill(0); for(let i=0;iv.toFixed(4)).join(', ')+']'); speak('Ran the model and produced an output.'); }catch(e){ add('bot','Error: '+e.message); speak('Model run failed.'); } return; } // Create checkpoint (parse size MB) if(/checkpoint|slim/.test(low)){ const m = low.match(/(\d+)\smb/); const targetMB = m? parseInt(m[1],10) : 512; try{ const {hashes,total} = await bucketizeLRU(targetMB1024*1024); const name = 'chat_ckpt' + Date.now(); const res = await exportCheckpoint(name, hashes, true); add('bot', Created checkpoint ${name} with ${res.hashes} chunks (~${Math.round(total/1024/1024)}MB) and evicted.); speak('Checkpoint created.'); }catch(e){ add('bot','Error: '+e.message); speak('Checkpoint failed.'); } return; } // Scan & index container if(/scan index|index container|build index/.test(low)){ try{ const idx = await scanAndIndex(); add('bot', Indexed ${idx.items.length} items.); speak('Indexing complete.'); }catch(e){ add('bot','Error: '+e.message); speak('Indexing failed.'); } return; } // Default help const help = "I can: 1) build websites (say: build a website …), 2) import GGUF by URL, 3) load demo weight + run, 4) create checkpoints (e.g., 'checkpoint 512MB'), 5) bind container, 6) scan index."; add('bot', help); speak('Here is what I can do right now.'); } function wire(){ // Init Speak/Mute state and button try { const pref = localStorage.getItem('chatSpeakOn'); const on = (pref === null) ? true : (pref === '1'); if (document.getElementById('chatSpeak')) document.getElementById('chatSpeak').checked = on; const btn = document.getElementById('chatSpeakBtn'); const setBtn = (enabled)=> { if(btn) btn.textContent = enabled ? '🔇 Mute' : '🔊 Speak'; }; setBtn(on); if(btn){ btn.onclick = ()=>{ const enabled = !(document.getElementById('chatSpeak')||{checked:on}).checked; if(document.getElementById('chatSpeak')) document.getElementById('chatSpeak').checked = enabled; localStorage.setItem('chatSpeakOn', enabled ? '1' : '0'); setBtn(enabled); }; } if(document.getElementById('chatSpeak')){ document.getElementById('chatSpeak').onchange = ()=>{ const enabled = document.getElementById('chatSpeak').checked; localStorage.setItem('chatSpeakOn', enabled ? '1' : '0'); setBtn(enabled); }; } } catch(e){} $('#chatSend').onclick = ()=>{ const t=$('#chatInput').value.trim(); if(!t) return; $('#chatInput').value=''; handle(t); }; $('#chatInput').addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); $('#chatSend').click(); } }); $('#chatMic').onclick = ()=>{ const r = ensureRecog(); if(!r){ add('bot','Speech recognition not supported.'); return; } if(!listening){ r.start(); listening=true; $('#chatMic').textContent='🛑 Stop'; r.onresult = (ev)=>{ const txt = ev.results[0][0].transcript; handle(txt); }; r.onerror = (ev)=>{ add('bot','Mic error: '+ev.error); }; r.onend = ()=>{ listening=false; $('#chatMic').textContent='🎤 Start'; }; }else{ r.stop(); } }; } return { wire, handle, add, speak }; })(); // ===== Maestro: Glyph Music ===== const Maestro = (()=>{ // Pitch mapping (16 semitone values for a nibble) const PITCHES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B','C+','C#+','D+','D#+']; // + means next octave const DUR = {s:0.25,e:0.5,q:1,h:2,w:4}; const STAFF = {top: 50, gap: 10}; // canvas staff settings function nibbleToNote(n, baseOct=4){ let p = PITCHES[n&15]; let addOct=0; if(p.includes('+')){ p=p.replace('+',''); addOct=1; } const pitch=p; const octave=baseOct+addOct; return {pitch, octave, dur:'e'}; } function noteToNibble(note){ const name = note.pitch.toUpperCase() + (note.sharp?'#':'') + (note.acc||''); let idx = PITCHES.indexOf(name); if(idx<0){ // treat higher octave as + versions const base = name.replace(/(\d+)/,''); // not used idx = PITCHES.indexOf(base); if(idx<0) idx = 0; } return idx & 15; } function byteToNotes(b){ return [nibbleToNote((b>>4)&15), nibbleToNote(b&15)]; } function notesToByte(n1,n2){ return ((noteToNibble(n1)&15)<<4) | (noteToNibble(n2)&15); } function textToU8(str){ return new TextEncoder().encode(str); } function u8ToText(u8){ return new TextDecoder().decode(u8); } // Score object: {format:'GSM1', notes:[{p:'C',o:4,d:'e'},...], meta:{sha256, bytes, preview:true}} function encodeBytesToScore(u8){ const notes=[]; for(let i=0;iwidth-30){ // new staff stack shiftStaff(ctx); x = 30; } } function yForNote(n){ const pitchOrder = ['C','D','E','F','G','A','B']; const base = staffTopBase + 4STAFF.gap; // E4 baseline const map = {'C':-2,'D':-1,'E':0,'F':1,'G':2,'A':3,'B':4}; const offset = map[n.p]!==undefined ? map[n.p] : 0; return base - offsetSTAFF.gap - (n.o-4)3STAFF.gap; } function drawNote(ctx,x,y){ ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.ellipse(x,y,5,7,0,0,Math.PI2); ctx.fill(); ctx.strokeStyle='#ddd'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(x+6,y); ctx.lineTo(x+6,y-25); ctx.stroke(); } function shiftStaff(ctx){ const dy = 140; STAFF.top += dy; for(let i=0;i<5;i++){ const y = staffTopBase + iSTAFF.gap; ctx.beginPath(); ctx.moveTo(20,y); ctx.lineTo(width-20,y); ctx.stroke(); } } } // Simple playback function playScore(score){ if(!('AudioContext' in window)) return; const ctx = new AudioContext(); const notes = score.notes||[]; let t = ctx.currentTime + 0.05; const tempo = 120; const beat = 60/tempo; for(const n of notes.slice(0,512)){ // cap to prevent very long sessions const freq = pitchToFreq(n.p, n.o||4); const dur = DUR[n.d||'e']||0.5; const osc = ctx.createOscillator(); const g = ctx.createGain(); osc.type='sine'; osc.frequency.value = freq; g.gain.setValueAtTime(0.0001, t); g.gain.linearRampToValueAtTime(0.12, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+durbeat); osc.connect(g).connect(ctx.destination); osc.start(t); osc.stop(t+durbeat+0.02); t += durbeat0.9; } } function pitchToFreq(p, octave){ const A4=440, map={'C':-9,'C#':-8,'D':-7,'D#':-6,'E':-5,'F':-4,'F#':-3,'G':-2,'G#':-1,'A':0,'A#':1,'B':2}; const semi = (octave-4)12 + (map[p]||0); return A4 * Math.pow(2, semi/12); } // Encode text async function encodeText(str){ const u8 = textToU8(str); const score = encodeBytesToScore(u8); await xpEmit('maestro.encode.text', {bytes:u8.length}); return score; } // Encode file (container-backed reference + small preview score) async function encodeFile(file, savePath){ const name = (file.name||'upload.bin').replace(/[^A-Za-z0-9_.-]/g,'_'); const path = savePath || ('scores/'+name+'.gscore'); const buf = new Uint8Array(await file.arrayBuffer()); let location='(embedded)'; try{ await Bridge.writeFile('files/'+name, buf); location = 'container://files/'+name; }catch(e){ / container not bound, fall back to embedded if small / } const sha = await sha256(buf); const previewLen = Math.min(buf.length, 4096); const score = encodeBytesToScore(buf.slice(0, previewLen)); score.meta = {...(score.meta||{}), name, sha256: sha, path: location, preview_bytes: previewLen, total_bytes: buf.length }; // Save .gscore into container if possible const text = JSON.stringify(score, null, 2); try{ await Bridge.writeFile(path, strToU8(text)); }catch(e){ / ignore / } await xpEmit('maestro.encode.file', {name, bytes: buf.length, path: location}); return score; } // Export helpers function exportPNG(canvas){ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='glyph_score.png'; a.click(); } function exportScore(score){ const blob=new Blob([JSON.stringify(score,null,2)], {type:'application/json'}); saveBlob(score.meta?.name? (score.meta.name+'.gscore') : 'score.gscore', blob); } return { encodeText, encodeFile, drawScore, playScore, exportPNG, exportScore, scoreToOneLine, oneLineToScore, decodeScoreToBytes }; })(); // ===== PyWeights (Python runtime + .pyweights) ===== let __pyodide = null; async function pywLoadRuntime(){ try{ if(__pyodide){ $('#pywStatus').textContent='Loaded'; return __pyodide; } const idx = ($('#pywIndexURL') ? $('#pywIndexURL').value.trim() : 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/'); await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src = idx + 'pyodide.js'; s.onload=res; s.onerror=()=>rej(new Error('Failed to load pyodide.js')); document.head.appendChild(s); }); if(!window.loadPyodide) throw new Error('loadPyodide not present'); __pyodide = await window.loadPyodide({ indexURL: idx }); $('#pywStatus').textContent = 'Loaded (' + (__pyodide.version||'') + ')'; $('#pywLog').textContent = 'Loaded Pyodide from ' + idx; await xpEmit('pyw.runtime.loaded', {indexURL: idx, version: __pyodide.version||null}); return _pyodide; }catch(e){ $('#pywStatus').textContent='Error'; $('#pywLog').textContent = 'Runtime load failed: ' + e.message; throw e; } } async function pywRun(code){ const p = await pywLoadRuntime(); try{ const out = await p.runPythonAsync(code); return out; }catch(e){ throw e; } } // Spec for .pyweights: // - JSON form: {"format":"PYW1","model_name":"...","model_id":"...","tensors":[{"name":"W1","dtype":"f16","shape":[...],"b64":"..."}]} // - Python form: defines either a callable build() returning the same dict, || a global PYW dict with "tensors". async function integratePyWeightsText(name, text, toContainer=true, savePath='weights/pyweights/model.pyweights'){ const u8 = strToU8(text); const sha = await sha256(u8); const modelId = 'pyw' + sha.slice(0,12); let location='(embedded)'; if(toContainer){ try{ await Bridge.writeFile(savePath || ('weights/pyweights/'+name), u8); location = 'container://' + (savePath||('weights/pyweights/'+name)); }catch(e){ / ignore / } } // Register model shell in WGDB await WGDB.put('models', modelId, { id:modelId, name: name || ('PyWeights '+sha.slice(0,8)), entry:{type:'pyweights', path: location, sha}, tensors: [] }); await xpEmit('pyw.integrate', {modelId, location, bytes: u8.byteLength}); return {modelId, sha, location}; } async function listPyWeightsModels(){ const ids = await WGDB.keys('models'); const out=[]; for(const id of ids){ const m = await WGDB.get('models', id); if(m && m.entry && m.entry.type==='pyweights') out.push(m); } return out; } async function materializePyWeightsModel(modelId){ const m = await WGDB.get('models', modelId); if(!m) throw new Error('No such model'); // Load the text content of the .pyweights from container || embedded let text = null; if(m.entry.path && m.entry.path.startsWith('container://')){ const rel = m.entry.path.replace('container://',''); const buf = await Bridge.readFile(rel); text = u8ToStr(buf); } else { throw new Error('Embedded .pyweights not stored; re-integrate with "save to container".'); } // Try JSON first let tensors = null, meta = {}; try{ const obj = JSON.parse(text); if(obj && (obj.format==='PYW1' || obj.format==='pyw1' || obj.format==='PyW1')){ // patched below if needed tensors = obj.tensors||[]; meta = obj; } }catch(_){ / not JSON, try Python / } if(!tensors){ // Run Python code and collect a dict const p = await pywLoadRuntime(); await p.FS.writeFile('/tmp_model.py', text); const code = import json, base64, sys\nns={}\ncode=open('/tmp_model.py','r',encoding='utf-8').read()\nexec(code, ns, ns)\nif 'build' in ns and callable(ns['build']):\n spec = ns['build']()\nelif 'PYW' in ns:\n spec = ns['PYW']\nelse:\n raise RuntimeError('No build() || PYW dict in .pyweights')\nprint(json.dumps(spec))\n; const out = await p.runPythonAsync(code); const spec = JSON.parse(String(out)); tensors = spec.get('tensors', []); meta = spec; } // Persist tensors into WGDB let count=0; for(const t of tensors){ const b64 = t.b64 || t.bytes || t.base64; if(!b64) continue; const data = fromB64(b64); const hash = await sha256(data); await WGDB.put('chunks', hash, data); await WGDB.put('tensors', ${modelId}:${t.name}, { sha256: hash, dtype: t.dtype||'bytes', shape: t.shape||[data.byteLength], bytes: data.byteLength }); const metaRec = await WGDB.get('meta', chunk:${hash}) || {bytes:data.byteLength,last:Date.now(),ckpt:null}; await WGDB.put('meta', chunk:${hash}, metaRec); count++; const cur = await WGDB.get('models', modelId); if(cur && !cur.tensors.includes(t.name)){ cur.tensors.push(t.name); await WGDB.put('models', modelId, cur); } } await xpEmit('pyw.materialize', {modelId, tensors: count}); return {count, modelId, name: m.name}; } async function exportModelAsPyWeights(modelId){ const m = await WGDB.get('models', modelId); if(!m) throw new Error('No such model'); const tensors=[]; for(const name of (m.tensors||[])){ const meta = await WGDB.get('tensors', ${modelId}:${name}); if(!meta) continue; const data = await WGDB.get('chunks', meta.sha256); if(!data) continue; const b64 = toB64(new Uint8Array(data)); tensors.push({name, dtype: meta.dtype||'bytes', shape: meta.shape||[meta.bytes], b64}); } const obj = {format:'PYW1', model_name: m.name, model_id: m.id, tensors}; const text = JSON.stringify(obj, null, 2); saveBlob((m.name||'model')+'.pyweights', new Blob([text], {type:'application/json'})); await xpEmit('pyw.export', {modelId, tensors: tensors.length}); return {count: tensors.length}; } // ===== GGUF Folder Indexing (container-backed, no full read) ===== async function registerGGUFStub(relPath, size){ try{ const name = (relPath.split('/').pop()||'model.gguf'); // Deterministic ID from path+size (avoid reading multi-GB into memory) const idHash = await sha256(strToU8('gguf-stub:'+relPath+':'+(size||0))); const modelId = 'gguf_' + idHash.slice(0,12); const existing = await WGDB.get('models', modelId); if(existing) return {modelId, existed:true}; await WGDB.put('tensors', ${modelId}:gguf_bytes, { sha256: stub:${relPath}, dtype: 'bytes', shape: [size||0], bytes: size||0 }); await WGDB.put('models', modelId, { id:modelId, name:name, entry:{type:'gguf-blob', path:'container://'+relPath, bytes:size||0}, tensors:['gguf_bytes'] }); await xpEmit('gguf.stub.register', {modelId, path: relPath, bytes: size||0}); return {modelId, existed:false}; }catch(e){ console.error('registerGGUFStub failed', e); throw e; } } async function indexGGUFFolders(){ // First try full-root scan if available try{ const res = await indexGGUFFromRoot(); if(res && res.scanned!==undefined) return res; }catch(_){ / continue to folder list / } const roots = ['Gguf','GGUF','gguf','weights/gguf','weights/Gguf','Weights/gguf']; const found = []; for(const root of roots){ try{ const entries = await Bridge.listRecursive(root); for(const ent of (entries||[])){ const path = ent.path || ent; const lower = path.toLowerCase(); if(lower.endsWith('.gguf')){ const size = ent.size || 0; found.push({path, size}); } } }catch(_){ / root may not exist; skip / } } let count=0, existed=0; for(const f of found){ try{ const r = await registerGGUFStub(f.path, f.size); if(r.existed) existed++; else count++; }catch(e){ / skip individual failures / } } await xpEmit('gguf.stub.indexed', {new:count, existed}); return {new:count, existed, scanned: found.length}; } // ===== GGUF Active-Weights Helpers ===== async function gatherGGUFModels(){ const ids = await WGDB.keys('models'); const out=[]; for(const id of ids){ const m = await WGDB.get('models', id); if(m && m.entry && m.entry.type === 'gguf-blob'){ out.push(m); } } return out; } async function setActiveGGUFStatusUI(n){ try{ const el=document.getElementById('ggufActiveCount'); if(el) el.textContent = String(n); }catch(){} } async function ensureGGUFActive(){ try{ // Ensure indexing (if container is bound) try{ await indexGGUFFolders(); }catch(){} const models = await gatherGGUFModels(); await setActiveGGUFStatusUI(models.length); // Build or update a profile model listing all GGUFs const profId = 'profile_gguf_all'; const tensors = []; for(const m of models){ tensors.push('ref_'+m.id); await WGDB.put('tensors', ${profId}:ref_${m.id}, { sha256: ref:${m.entry.path}, dtype: 'ref', shape: [m.entry.bytes||0], bytes: m.entry.bytes||0 }); } const profile = { id: profId, name:'All GGUF Weights', entry:{ type:'profile', kind:'gguf-all', count: models.length, created: nowISO() }, tensors }; await WGDB.put('models', profId, profile); await WGDB.put('meta', 'active.gguf.profile', { id: profId, time: Date.now(), count: models.length }); await xpEmit('agent.gguf.active', {profile: profId, count: models.length}); return profile; }catch(e){ console.error('ensureGGUFActive failed', e); return null; } } // ===== Autopilot: Rules Engine & Checklist ===== const AP = (()=>{ const log = (msg)=>{ const el=$('#apLog'); if(!el) return; el.textContent += (msg+'\n'); el.scrollTop = el.scrollHeight; }; async function hasContainer(){ try{ const st = await Bridge.status(); return !!(st && st.bound); }catch(){ return false; } } async function countGGUF(){ const ms = await gatherGGUFModels().catch(()=>[]); return ms.length||0; } async function hasSW(){ try{ return 'serviceWorker' in navigator && !!navigator.serviceWorker.controller; }catch(){ return false; } } async function sttSupport(){ return (('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window)) ? true : false; } async function ttsSupport(){ return !!window.speechSynthesis; } async function pywNeeded(){ // needed if any pyweights model exists const ids = await WGDB.keys('models'); for(const id of ids){ const m=await WGDB.get('models',id); if(m?.entry?.type==='pyweights') return true; } return false; } async function pywLoaded(){ return !!window.__pyodide; } async function wgDemoOK(){ try{ const id = await createDemoWeightGlyph(); const vec=new Array(16).fill(0).map(()=> (Math.random()2-1)0.1); const out = await runMLP_CPU(id, vec); return Array.isArray(out) && out.length===8; }catch(){ return false; } } async function journalOK(){ try{ await addJournal({type:'ap.test', ok:true}); return true; }catch(){ return false; } } async function gsc2OK(){ try{ const cap = await encodeCapsuleGSC2({ name:'APTest', files:{'index.html':'ok '} }); const dec = await decodeCapsule(cap); return !!(dec && dec.files && dec.files['index.html']); }catch(){ return false; } } async function maestroOK(){ try{ const s = await Maestro.encodeText('ap'); const bytes = Maestro.decodeScoreToBytes(s); return bytes && bytes.length>0; }catch(){ return false; } } // Rule definitions // status: pass/fail/needs‑action/optional const RULES = [ { id:'container.bound', title:'Bind Container Directory', desc:'Bind a disk folder for effectively unlimited storage', check: async()=> await hasContainer(), fix: async()=>{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8('{}')); return true; }, requiresUserAction:true }, { id:'gguf.indexed', title:'Index GGUF folders & activate profile', desc:'Scan Gguf/weights/gguf and set All‑GGUF profile', check: async()=> (await countGGUF())>0, fix: async()=>{ await indexGGUFFolders(); const prof=await ensureGGUFActive(); return (prof && prof.tensors && prof.tensors.length>0); } }, { id:'gsc2.engine', title:'Glyph capsule engine functional', desc:'Encode/decode GSC2 capsule', check: gsc2OK, fix: gsc2OK }, { id:'wg.demo', title:'Weights engine (CPU MLP) working', desc:'Create demo MLP and run inference', check: wgDemoOK, fix: wgDemoOK }, { id:'maestro.core', title:'Maestro encode/decode working', desc:'Encode text→score and decode back', check: maestroOK, fix: maestroOK }, { id:'chat.stt', title:'Voice input available', desc:'SpeechRecognition support (if not, still usable via typing)', check: sttSupport, optional:true }, { id:'chat.tts', title:'Speech output available', desc:'speechSynthesis support', check: ttsSupport, optional:true }, { id:'pyw.runtime', title:'Python runtime loaded (if needed)', desc:'Load Pyodide when .pyweights models exist', check: async()=> (await pywNeeded()) ? await pywLoaded() : true, fix: async()=>{ if(await pywNeeded()){ await pywLoadRuntime(); return true; } return true; } }, { id:'sw.ready', title:'Offline service worker active', desc:'Cache basic assets for resilience', check: hasSW, optional:true }, { id:'journal.ok', title:'Journal writable', desc:'Append an event to journal log', check: journalOK, fix: journalOK } ]; async function assess(){ const results=[]; for(const r of RULES){ let ok=false, note='', needsAction=false, optional=!!r.optional; try{ ok = await r.check(); }catch(e){ ok=false; note = e.message; } if(!ok && r.requiresUserAction) needsAction=true; results.push({id:r.id, title:r.title, desc:r.desc, ok, note, needsAction, optional}); } await xpEmit('ap.assess', {results}); return results; } async function upgrade(results){ const out=[]; for(const r of RULES){ const cur = results.find(x=>x.id===r.id); if(cur && cur.ok) { out.push({id:r.id, changed:false}); continue; } if(r.fix){ try{ const res = await r.fix(); out.push({id:r.id, changed: !!res}); }catch(e){ out.push({id:r.id, changed:false, error:e.message}); } }else{ out.push({id:r.id, changed:false}); } } await xpEmit('ap.upgrade', {changes: out}); return out; } function render(results){ const list=$('#apList'); const sum=$('#apSummary'); if(!list || !sum) return; list.innerHTML=''; let pass=0, fail=0, opt=0, needs=0; for(const r of results){ const row=document.createElement('div'); row.className='card'; const status = r.ok ? 'PASS' : (r.needsAction ? 'ACTION' : (r.optional ? 'OPTIONAL' : 'FAIL')); if(r.ok) pass++; else if(r.optional) opt++; else if(r.needsAction) needs++; else fail++; row.innerHTML =    ${r.title}   ${r.desc}   ${status}   ${r.note?('   '+r.note+'   '):''}; list.appendChild(row); } sum.innerHTML = Summary: PASS ${pass} · FAIL ${fail} · ACTION ${needs} · OPTIONAL ${opt}; } async function runAssess(){ log('Assessing…'); const res = await assess(); render(res); return res; } async function runUpgrade(){ const res = await runAssess(); log('Upgrading…'); const changes = await upgrade(res); // Reassess const res2 = await runAssess(); return {changes, res2}; } return { runAssess, runUpgrade }; })(); // ===== Deployment helpers ===== let __deferredInstallEvent = null; window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); __deferredInstallEvent = e; const log = $('#deployPwaLog'); if(log) log.textContent += 'Install prompt ready.\n'; }); $('#pwaInstall')?.addEventListener('click', async ()=>{ try{ if(__deferredInstallEvent){ __deferredInstallEvent.prompt(); const ch = await __deferredInstallEvent.userChoice; $('#deployPwaLog').textContent += 'Choice: '+ch.outcome+'\n'; } else { $('#deployPwaLog').textContent += 'Install prompt not yet available. Ensure HTTPS/localhost.\n'; } }catch(e){ $('#deployPwaLog').textContent += 'Error: '+e.message+'\n'; } }); $('#pwaUnregister')?.addEventListener('click', async ()=>{ try{ const regs = await navigator.serviceWorker?.getRegistrations?.(); if(regs){ for(const r of regs){ await r.unregister(); } } localStorage.clear(); $('#deployPwaLog').textContent += 'Service worker unregistered and localStorage cleared.\n'; }catch(e){ $('#deployPwaLog').textContent += 'Error: '+e.message+'\n'; } }); // Copy blocks document.querySelectorAll('.copyme').forEach(el=>{ el.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(el.getAttribute('data-copy')||el.textContent.trim()); el.style.outline='1px solid #4caf50'; setTimeout(()=>el.style.outline='none', 600);}catch(){} }); }); // Manifest injection (single-file friendly) (function ensureManifest(){ try{ const manifest = { name: "GlyphNotes", short_name: "GlyphNotes", start_url: "./", display: "standalone", background_color: "#0b1330", theme_color: "#0b1330", icons: [] }; const blob = new Blob([JSON.stringify(manifest)], {type:'application/manifest+json'}); const url = URL.createObjectURL(blob); let link = document.querySelector('link[rel="manifest"]'); if(!link){ link = document.createElement('link'); link.rel='manifest'; document.head.appendChild(link); } link.href = url; }catch(){} })(); // WGDB export/import async function exportWGDBAll(){ const stores = ['models','tensors','chunks','meta']; let n=0; const enc = new TextEncoder(); const chunks = []; for(const s of stores){ const keys = await WGDB.keys(s); for(const k of keys){ const v = await WGDB.get(s, k); const rec = JSON.stringify({store:s, key:k, value: (s==='chunks' && v && v.buffer)? Array.from(new Uint8Array(v)) : v}); chunks.push(rec+'\n'); n++; } } const blob = new Blob(chunks, {type:'application/x-ndjson'}); saveBlob('glyphnotes_state.jsonl', blob); return n; } async function importWGDBAll(file){ const text = await file.text(); let n=0, bad=0; for(const line of text.split(/\r?\n/)){ if(!line.trim()) continue; try{ const rec = JSON.parse(line); let val = rec.value; if(rec.store==='chunks' && Array.isArray(val)){ val = new Uint8Array(val); } await WGDB.put(rec.store, rec.key, val); n++; }catch(_){ bad++; } } return {n,bad}; } $('#exportWGDB')?.addEventListener('click', async ()=>{ try{ const n = await exportWGDBAll(); $('#wgdbLog').textContent = Exported ${n} records.; }catch(e){ $('#wgdbLog').textContent = 'Error: '+e.message; } }); $('#importWGDB')?.addEventListener('click', ()=> $('#importWGDBFile').click()); $('#importWGDBFile')?.addEventListener('change', async (e)=>{ const f = e.target.files[0]; if(!f) return; try{ const r = await importWGDBAll(f); $('#wgdbLog').textContent = Imported ${r.n} records. Failed ${r.bad}.; }catch(err){ $('#wgdbLog').textContent = 'Error: '+err.message; } }); // GGUF verification (fast or full) async function ggufFingerprintFast(rel){ const f = await Bridge.getFileHandle(rel); const file = await f.getFile(); const size = file.size; const reader = file.stream().getReader(); // Read first 1 MiB let first = new Uint8Array(0), last = new Uint8Array(0); let loaded = 0; const firstTarget = 10241024; const lastTarget = 10241024; let chunks=[]; while(true){ const {done, value} = await reader.read(); if(done) break; loaded += value.byteLength; chunks.push(value); if(first.byteLength < firstTarget){ const need = firstTarget - first.byteLength; const take = value.slice(0, Math.min(need, value.byteLength)); const merged = new Uint8Array(first.byteLength + take.byteLength); merged.set(first,0); merged.set(take, first.byteLength); first = merged; }else{ // keep sliding window for last const merged = new Uint8Array(last.byteLength + value.byteLength); merged.set(last,0); merged.set(value, last.byteLength); if(merged.byteLength > lastTarget){ last = merged.slice(merged.byteLength - lastTarget); }else last = merged; } // Avoid keeping all chunks if(chunks.length>8) chunks = chunks.slice(-2); } const fpInput = new Uint8Array(first.byteLength+last.byteLength+8); fpInput.set(first,0); fpInput.set(last, first.byteLength); // Append size as 64-bit little endian const dv = new DataView(fpInput.buffer); dv.setBigUint64(fpInput.byteLength-8, BigInt(size), true); const hash = await sha256(fpInput); return {mode:'fast', size, hash}; } async function ggufHashFull(rel){ // Read in chunks and compute JS incremental SHA‑256 (fallback when SubtleCrypto can't stream) // Minimal incremental SHA‑256 implementation function Sha256(){ this.h=new Uint32Array([1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225]); this.buf=new Uint8Array(64); this.view=new DataView(this.buf.buffer); this.len=0; this.pos=0; } Sha256.prototype._rotr=function(x,n){ return (x>>>n)|(x<<(32-n)); } Sha256.prototype._ch=function(x,y,z){ return (x & y) ^ (~x & z); } Sha256.prototype._maj=function(x,y,z){ return (x & y) ^ (x & z) ^ (y & z); } Sha256.prototype._s0=function(x){ return this._rotr(x,2)^this._rotr(x,13)^this._rotr(x,22); } Sha256.prototype._s1=function(x){ return this._rotr(x,6)^this._rotr(x,11)^this._rotr(x,25); } Sha256.prototype._g0=function(x){ return this._rotr(x,7)^this._rotr(x,18)^(x>>>3); } Sha256.prototype._g1=function(x){ return this._rotr(x,17)^this._rotr(x,19)^(x>>>10); } Sha256.prototype._k=new Int32Array([1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822214,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998]); Sha256.prototype.update=function(data){ let i=0; this.len+=data.byteLength; while(i56){ while(this.pos<64) this.buf[this.pos++]=0; this._compress(); this.pos=0; } while(this.pos<56) this.buf[this.pos++]=0; const v = new DataView(this.buf.buffer); v.setUint32(56, Math.floor(bitLen/0x100000000)); v.setUint32(60, bitLen>>>0); this._compress(); const out=new Uint8Array(32); const dv=new DataView(out.buffer); for(let i=0;i<8;i++) dv.setInt32(i4, this.h[i]); return out; } const f = await Bridge.getFileHandle(rel); const file = await f.getFile(); const reader = file.stream().getReader(); const sha = new Sha256(); while(true){ const {done, value} = await reader.read(); if(done) break; sha.update(value); } const out = sha.digest(); const hex = Array.from(out).map(b=>b.toString(16).padStart(2,'0')).join(''); return {mode:'full', size: file.size, hash: hex}; } $('#ggufVerifyGo')?.addEventListener('click', async ()=>{ try{ const rel = $('#ggufVerifyPath').value.trim(); const mode = $('#ggufVerifyMode').value; const res = (mode==='fast') ? await ggufFingerprintFast(rel) : await ggufHashFull(rel); $('#ggufVerifyOut').textContent = JSON.stringify(res, null, 2); }catch(e){ $('#ggufVerifyOut').textContent = 'Error: '+e.message; } }); // Export logs $('#exportJournal')?.addEventListener('click', async ()=>{ try{ const blob = new Blob([JSON.stringify(await loadJournal(), null, 2)], {type:'application/json'}); saveBlob('journal.json', blob); $('#logOut').textContent = 'Journal exported.'; }catch(e){ $('#logOut').textContent = 'Error: '+e.message; } }); $('#exportXP')?.addEventListener('click', async ()=>{ try{ const xs = await xpList(); const blob = new Blob([JSON.stringify(xs, null, 2)], {type:'application/json'}); saveBlob('experience.json', blob); $('#logOut').textContent = 'Experience weights exported.'; }catch(e){ $('#logOut').textContent = 'Error: '+e.message; } }); // ===== Setup Wizard & Image Encoder ===== async function setupRequestStorage(){ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); $('#stPerm').textContent = 'Granted'; return true; }catch(e){ $('#stPerm').textContent = 'Denied: '+e.message; return false; } } async function setupGlyphEngines(){ // Ensure engines OK: capsule, demo weight, maestro let ok = true; try{ const g = await (async()=>{ const cap = await encodeCapsuleGSC2({name:'SetupTest', files:{'index.html':'
ok
'}}); const dec = await decodeCapsule(cap); return !!dec?.files?.['index.html']; })(); ok = ok && g; }catch(e){ ok=false; } try{ const id = await createDemoWeightGlyph(); const vec=new Array(16).fill(0).map(()=> (Math.random()*2-1)*0.1); const out = await runMLP_CPU(id, vec); ok = ok && Array.isArray(out) && out.length===8; }catch(e){ ok=false; } try{ const s = await Maestro.encodeText('setup'); const b = Maestro.decodeScoreToBytes(s); ok = ok && (b && b.length>0); }catch(e){ ok=false; } $('#stGlyph').textContent = ok ? 'Ready' : 'Issues'; return ok; } function strToBytes(str){ return new TextEncoder().encode(str); } function bytesToStr(u8){ return new TextDecoder().decode(u8); } function writeLE32(view, off, v){ view.setUint32(off, v>>>0, true); } async function encodeAppToPNG(relPath){ try{ const html = document.documentElement.outerHTML; const bytes = strToBytes(html); const magic = strToBytes('GLYPHIMG1'); const header = new Uint8Array(16); header.set(magic,0); const view = new DataView(header.buffer); writeLE32(view, 8, bytes.length); const payload = new Uint8Array(header.length + bytes.length); payload.set(header,0); payload.set(bytes, header.length); // Compute image size: pack as RGBA const total = payload.length; const pixels = Math.ceil(total/4); const w = Math.ceil(Math.sqrt(pixels)); const h = Math.ceil(pixels / w); const canvas = document.createElement('canvas'); canvas.width=w; canvas.height=h; const ctx = canvas.getContext('2d'); const img = ctx.createImageData(w,h); for(let i=0, j=0; i canvas.toBlob(res, 'image/png')); const arr = new Uint8Array(await blob.arrayBuffer()); try{ await Bridge.writeFile(relPath, arr); }catch(){} saveBlob(relPath.split('/').pop()||'system_seed.png', blob); $('#imgLog').textContent = Created ${relPath} (${w}x${h}, ${total} bytes payload); $('#stImage').textContent = 'Created'; await xpEmit('image.seed.created', {relPath, w, h, total}); return {w,h,total}; }catch(e){ $('#imgLog').textContent = 'Error: '+e.message; return null; } } async function decodePNGToApp(file){ const buf = new Uint8Array(await file.arrayBuffer()); const url = URL.createObjectURL(new Blob([buf], {type:'image/png'})); const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=()=>rej(new Error('Bad PNG')); img.src=url; }); const canvas = document.createElement('canvas'); canvas.width=img.width; canvas.height=img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0); const data = ctx.getImageData(0,0,canvas.width,canvas.height).data; const payload = new Uint8Array(data.length); for(let i=0;i{ // Try GSC2 capsule try{ const text = new TextDecoder().decode(bytes); if(text.startsWith('{') && text.includes('"gsc2"')){ await restoreCheckpointFromText(text).catch(()=>{}); } }catch(){} // If looks like html, preview try{ const txt = new TextDecoder().decode(bytes); if(/{ if(oldDec) try{ await oldDec(); }catch(){} try{ const sc = JSON.parse($('#mzScoreJSON').value.trim()); const bytes = Maestro.decodeScoreToBytes(sc); await runAuto(bytes); $('#stMaestro').textContent = 'Auto‑exec ready'; }catch(){} }; } $('#stMaestro').textContent = 'Ready'; return true; } async function startSetupWizard(){ const log = (m)=>{ const el=$('#setupLog'); el.textContent += m+'\n'; el.scrollTop = el.scrollHeight; }; log('Requesting storage permission…'); const perm = await setupRequestStorage(); if(!perm){ log('Storage permission denied; wizard cannot continue.'); return; } log('Configuring glyph engines…'); await ensureGGUFActive().catch(()=>{}); const ok = await setupGlyphEngines(); log(ok ? 'Glyph engines ready.' : 'Some glyph checks failed, continuing.'); log('Encoding the entire app into a single PNG…'); const rel = $('#imgSaveAs').value.trim() || 'images/system_seed.png'; await encodeAppToPNG(rel); log('Setting Maestro auto‑execute…'); await setupMaestroAuto(); log('Setup complete.'); } // ===== Startup Guard & Robust Root Scanning ===== function showStartupGuard(msg){ let g = document.getElementById('startupGuard'); if(!g){ g = document.createElement('div'); g.id='startupGuard'; g.style.cssText='position:fixed;inset:0;background:rgba(5,8,20,.92);z-index:9999;display:flex;align-items:center;justify-content:center'; g.innerHTML = `
Setup Required
${msg||'This app needs storage access to your GGUF/weights folder.'}

Grant storage permission
Close
Tip: For full features, open over HTTPS or http://localhost (not file://).
; document.body.appendChild(g); document.getElementById('guardClose').onclick = ()=> g.remove(); document.getElementById('guardBind').onclick = async ()=>{ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); g.remove(); await afterBindSuccess(); }catch(e){ alert('Bind failed: '+e.message); } }; } } async function afterBindSuccess(){ try{ // Update header const st = await Bridge.status?.() || {bound:true}; document.getElementById('hdrBound').textContent = st.bound ? 'Yes' : 'Yes'; }catch(_){ document.getElementById('hdrBound').textContent = 'Yes'; } try{ await indexGGUFFromRoot(); }catch(_){} try{ const prof = await ensureGGUFActive(); document.getElementById('hdrGGUFs').textContent = String(prof?.tensors?.length||0);}catch(_){} try{ await AP?.runAssess?.(); }catch(_){} } // Extend GGUF indexing to scan entire root when available. async function indexGGUFFromRoot(){ const found = []; try{ const entries = await Bridge.listRecursive(''); // scan root for(const ent of (entries||[])){ const p = (ent.path||ent); if(String(p).toLowerCase().endsWith('.gguf')){ found.push({path:p, size: ent.size||0}); } } }catch(_){ /* no root listing; fall back */ } // If root scan empty, fall back to existing folder list if(found.length===0){ try{ const r = await indexGGUFFolders(); // will scan Gguf/weights/gguf, etc. return r; }catch(e){ throw e; } }else{ let count=0, existed=0; for(const f of found){ try{ const r = await registerGGUFStub(f.path, f.size); if(r.existed) existed++; else count++; }catch(_){} } await xpEmit('gguf.stub.indexed', {new:count, existed, scanned: found.length}); return {new:count, existed, scanned: found.length}; } } // Header bind button document.addEventListener('DOMContentLoaded', async ()=>{ // file:// warning if(location.protocol==='file:'){ setTimeout(()=>showStartupGuard('You opened the app from file://. Many APIs (storage, mic, SW) are blocked. Please serve over HTTPS or http://localhost. Click below to still try binding storage.'), 300); } // Hook bind button const b = document.getElementById('bindNow'); if(b){ b.onclick = async ()=>{ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); await afterBindSuccess(); alert('Storage bound.'); }catch(e){ alert('Bind failed: '+e.message); } }; } // Update header state where possible; if not bound, show guard try{ const st = await Bridge.status?.(); if(!st || !st.bound){ showStartupGuard(); } else{ document.getElementById('hdrBound').textContent = 'Yes'; try{ await indexGGUFFromRoot(); }catch(_){} try{ const prof = await ensureGGUFActive(); document.getElementById('hdrGGUFs').textContent = String(prof?.tensors?.length||0);}catch(_){} } }catch(_){ // No status; still prompt showStartupGuard(); } }); // ===== Bridge Fallback (File System Access) & Diagnostics ===== (function ensureBridge(){ if(window.Bridge && typeof Bridge.pickContainer==='function') return; const Bridge = {}; window.Bridge = Bridge; let rootHandle = null; Bridge.persist = async function(){ try{ await navigator.storage?.persist?.(); }catch(_){} return true; }; Bridge.pickContainer = async function(){ if(!('showDirectoryPicker' in window)) throw new Error('showDirectoryPicker not supported in this browser. Use Chrome/Edge over HTTPS or localhost.'); rootHandle = await window.showDirectoryPicker({mode:'readwrite'}); return true; }; Bridge.status = async function(){ return {bound: !!rootHandle}; }; async function getDir(path, create){ const parts = path.split('/').filter(Boolean); let dir = rootHandle; for(let i=0;irootHandle) : rootHandle; return await walk(start, subdir||''); }; Bridge.fetchTo = async function(rel, url){ const r = await fetch(url); if(!r.ok) throw new Error('HTTP '+r.status); const buf = new Uint8Array(await r.arrayBuffer()); await Bridge.writeFile(rel, buf); return {bytes: buf.byteLength}; }; })(); // Global error capture to Diagnostics (function hookErrors(){ const E = []; function add(msg){ try{ E.push(msg); const el=document.getElementById('diagErrors'); if(el){ el.textContent = E.join('\n'); el.scrollTop = el.scrollHeight; } }catch(_){ } } window.addEventListener('error', e=> add('Error: '+(e.message||e.error||'unknown'))); window.addEventListener('unhandledrejection', e=> add('Unhandled: '+(e.reason && (e.reason.message||e.reason) || 'unknown'))); window.__diagAdd = add; })(); // Diagnostics UI (function wireDiagnostics(){ const btn = document.getElementById('openDiag'); const modal = document.getElementById('diagModal'); const closeBtn = document.getElementById('diagClose'); function refreshEnv(){ const set=(id,val)=>{ const el=document.getElementById(id); if(el) el.textContent = String(val); }; set('dSecure', window.isSecureContext); set('dFSA', !!window.showDirectoryPicker); set('dSTT', !!(window.SpeechRecognition||window.webkitSpeechRecognition)); set('dTTS', !!window.speechSynthesis); set('dSW', 'serviceWorker' in navigator); set('dPicker', !!window.showDirectoryPicker); } async function refreshStatus(){ try{ const st = await Bridge.status?.() || {bound:false}; document.getElementById('dBound').textContent = st.bound ? 'Yes' : 'No'; const m = await gatherGGUFModels().catch(()=>[]); document.getElementById('dGGUFs').textContent = String(m.length||0); const meta = await WGDB.get('meta','active.gguf.profile').catch(()=>null); document.getElementById('dProfile').textContent = meta ? meta.id : 'None'; }catch(e){ window.__diagAdd('Status error: '+e.message); } } function open(){ modal.style.display='block'; refreshEnv(); refreshStatus(); } function close(){ modal.style.display='none'; } if(btn) btn.onclick = open; if(closeBtn) closeBtn.onclick = close; })(); // Header "Run Setup" button document.getElementById('runSetupNow')?.addEventListener('click', ()=>{ try{ startSetupWizard(); }catch(e){ alert('Setup error: '+e.message); } }); // ===== Agent pipeline ===== async function autoGlyph(text){ await ensureGGUFActive(); try{ if(document.getElementById('apAuto')?.checked){ await AP.runAssess(); } }catch(_){} const route=NB_MODEL.predict(text); const spec=parseSpec(text); const files=genSite(spec); const tar=tarPack(files); const manifest={ version:2, request:text, route, name: spec.name, time:nowISO() }; const files2=[ {name:"manifest.json", data:strToU8(JSON.stringify(manifest,null,2))}, {name:payload_${route}.tar, data:tar} ]; const unified=tarPack(files2); const capsule=await encodeCapsuleGSC2(unified, {kind:'unified', name:Unified_${manifest.name}}); await GlyphFS.save(Unified_${manifest.name}, capsule); downloadText(Unified_${manifest.name}.gvol, capsule); await executeUnifiedGlyph(unified); await refreshVolumesUI(); await addJournal({type:'agent.unified', route, name: manifest.name}); await xpEmit('agent.unified', {route, name: manifest.name}); } // ===== Wire UI ===== window.addEventListener('DOMContentLoaded',()=>{ // Tabs document.querySelector('.tabbar button[data-tab="agent"]').click(); $('#setVerify').checked = localStorage.getItem('setVerify')==='1'; $('#setVerify').onchange = e=> localStorage.setItem('setVerify', e.target.checked?'1':'0'); // Agent $('#activate').onclick = ()=> autoGlyph($('#ask').value || 'build a website name=Atlas blog contact dashboard'); $('#btnWeb').onclick = ()=> autoGlyph('build a website name=Atlas with blog contact dashboard'); $('#btnSelfTest').onclick = async ()=>{ await autoGlyph('build a website name=SelfTest'); }; // Volumes $('#volRefresh').onclick = refreshVolumesUI; $('#volImport').onclick = async ()=>{ const f=$('#volImportFile').files[0]; if(!f) return; const text=await f.text(); try{ const dec=await decodeCapsule(text, $('#setVerify').checked); const name=(dec.meta&&dec.meta.name)?dec.meta.name:(f.name.replace(/\.gvol$/,'')); await GlyphFS.save(name, text); await refreshVolumesUI(); await executeUnifiedGlyph(dec.bytes); await addJournal({type:'import.gvol', name}); await xpEmit('import.gvol', {name}); await refreshJournal(); }catch(e){ alert('Invalid glyph: '+e.message); } }; $('#importCode').onclick = async ()=>{ const line=$('#codeLine').value.trim(); if(!line) return; try{ const dec=await decodeCapsule(line, $('#setVerify').checked); const name=(dec.meta&&dec.meta.name)?dec.meta.name:('code_'+Date.now()); await GlyphFS.save(name, line); await refreshVolumesUI(); await executeUnifiedGlyph(dec.bytes); await addJournal({type:'import.code', name}); await xpEmit('import.code', {name}); await refreshJournal(); }catch(e){ alert('Bad glyph code: '+e.message); } }; refreshVolumesUI(); // Weights const refreshWG = async ()=>{ const models = await wgListModels(); $('#wgModels').textContent = models.length; $('#wgChunks').textContent = await wgChunkCount(); const sel=$('#wgModelSel'); sel.innerHTML=''; const ckSel=$('#ckptModels'); ckSel.innerHTML=''; models.forEach(m=>{ const o=document.createElement('option'); o.value=m.id; o.textContent = ${m.name} (${m.id.slice(0,8)}); sel.appendChild(o); const o2=o.cloneNode(true); ckSel.appendChild(o2); }); if(models.length){ $('#wgInfo').textContent = JSON.stringify(models[0], null, 2); } }; $('#wgImport').onclick = async ()=>{ const f=$('#wgImportFile').files[0]; if(!f) return; const text = await f.text(); try{ const res = await wgIndexFromCapsuleText(text); await addJournal({type:'wg.indexed', id:res.id, tensors:res.tensors}); await xpEmit('wg.indexed', {id:res.id, tensors:res.tensors}); $('#wgInfo').textContent = JSON.stringify(await WGDB.get('models', res.id), null, 2); await refreshWG(); }catch(e){ alert('WG import failed: '+e.message); } }; $('#wgDemo').onclick = async ()=>{ const id = await createDemoWeightGlyph(); await addJournal({type:'wg.demo.ready', id}); await xpEmit('wg.demo.ready', {id}); await refreshWG(); }; $('#wgModelSel').onchange = async ()=>{ const id=$('#wgModelSel').value; const m=await WGDB.get('models', id); $('#wgInfo').textContent = JSON.stringify(m, null, 2); }; $('#wgRun').onclick = async ()=>{ const id=$('#wgModelSel').value; if(!id){ alert('No model.'); return; } let x = $('#wgInput').value.trim(); let vec=[]; if(/^text:/.test(x)){ const s=x.slice(5); const inDim=16; vec=new Array(inDim).fill(0); for(let i=0;iparseFloat(v)||0) : new Array(16).fill(0); } try{ const out = await runMLP_CPU(id, vec); $('#wgOut').textContent = 'out: ['+out.map(v=>v.toFixed(4)).join(', ')+']'; }catch(e){ $('#wgOut').textContent = 'error: '+e.message; } }; // Checkpoints $('#ckptMake').onclick = async ()=>{ const sel = Array.from($('#ckptModels').selectedOptions).map(o=>o.value); if(!sel.length){ alert('Select at least one model'); return; } const name = $('#ckptName').value.trim() || ('Ckpt_'+Date.now()); const evict = $('#ckptEvict').checked; const hashes = await collectChunksForModels(sel); const res = await exportCheckpoint(name, hashes, evict); $('#ckptLog').textContent = checkpoint ${name}: chunks=${res.hashes}, capsuleLen=${res.capsuleLen}; await addJournal({type:'ckpt.create', name, hashes:res.hashes, evict}); await xpEmit('ckpt.create', {name, count:res.hashes, evict}); await refreshWG(); }; $('#slimRun').onclick = async ()=>{ const mb = Math.max(1, parseInt($('#slimTarget').value||'512',10)); const evict = $('#slimEvict').checked; const name = $('#slimName').value.trim() || ('LRU_'+Date.now()); const {hashes,total} = await bucketizeLRU(mb*1024*1024); const res = await exportCheckpoint(name, hashes, evict); $('#slimLog').textContent = auto‑slim ${name}: ${Math.round(total/1024/1024)} MB → chunks=${res.hashes}; await addJournal({type:'ckpt.auto', name, total}); await xpEmit('ckpt.auto', {name, total}); await refreshWG(); }; $('#ckptImport').onclick = async ()=>{ const f=$('#ckptImportFile').files[0]; if(!f) return; const text=await f.text(); const res = await restoreCheckpointFromText(text); $('#ckptRestoreLog').textContent = restored ${res.restored} chunks from ${res.name}; await addJournal({type:'ckpt.restore', name:res.name, restored:res.restored}); await xpEmit('ckpt.restore', {name:res.name, restored:res.restored}); await refreshWG(); }; // Container const status = { fsSupported: 'showDirectoryPicker' in window, bound:false, name:'(none)' }; async function refreshStatus(){ $('#fsSupport').textContent = status.fsSupported ? 'Yes' : 'No (requires Chromium + HTTPS/localhost)'; const dir = await Bridge.getContainer(); status.bound = !!dir; $('#fsBound').textContent = status.bound ? 'Yes' : 'No'; $('#fsName').textContent = status.bound ? (dir.name||'(granted)') : '—'; const pers = await Bridge.persisted(); $('#persisted').textContent = pers===null? '(n/a)' : (pers? 'Yes' : 'No'); } $('#persistAsk').onclick = async ()=>{ const ok = await Bridge.persist(); $('#persisted').textContent = ok? 'Yes' : 'No'; }; $('#upgradeBtn').onclick = async ()=>{ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); await Bridge.writeFile('README.txt', strToU8('Glyph Container: chunks/, capsules/, files/, index/')); await refreshStatus(); }catch(e){ alert('Bind failed: '+e.message); } }; $('#fetchGo').onclick = async ()=>{ const url = $('#fetchURL').value.trim(); const rel = $('#fetchAs').value.trim() || 'files/download.bin'; try{ const res = await fetchToContainer(url, rel); $('#fetchLog').textContent = Stored ${rel} (${res.bytes} bytes) sha256=${res.sha}; await addJournal({type:'container.fetch', rel, bytes:res.bytes, sha:res.sha}); await xpEmit('container.fetch', {rel, bytes:res.bytes, sha:res.sha}); }catch(e){ $('#fetchLog').textContent = 'Error: ' + e.message; } }; $('#indexScan').onclick = async ()=>{ try{ const idx = await scanAndIndex(); $('#indexLog').textContent = JSON.stringify(idx, null, 2); await addJournal({type:'container.index', count: (idx.items||[]).length}); await xpEmit('container.index', {count:(idx.items||[]).length}); }catch(e){ $('#indexLog').textContent = 'Error: ' + e.message + ' (bind container first)'; } }; $('#indexExport').onclick = async ()=>{ try{ const buf = await Bridge.readFile('index/objects.json'); const blob = new Blob([buf], {type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='objects.json'; a.click(); }catch(e){ $('#indexLog').textContent = 'No index yet.'; } }; refreshStatus(); // Storage tab async function refreshQuota(){ const est = await estimateQuota(); if(!est){ $('#quotaText').textContent='(no estimate)'; return {pct:0}; } const usedMB = (est.usage/1024/1024).toFixed(1), totalMB=(est.quota/1024/1024).toFixed(1); const pct = est.quota ? Math.round((est.usage/est.quota)*100) : 0; $('#quotaText').textContent = ${usedMB} MB / ${totalMB} MB (${pct}%); const b=$('#quotaBadge'); b.textContent = pct>80? 'high' : 'ok'; b.className='badge ' + (pct>90?'err':(pct>80?'warn':'ok')); return {pct}; } refreshQuota(); $('#simPressure').onclick = async ()=>{ const est = await refreshQuota(); if(est && est.pct>80){ $('#storageLog').textContent = 'Recommendation: create an LRU checkpoint of ~512MB now.'; } else { $('#storageLog').textContent = 'Plenty of headroom.'; } }; $('#autoCkptToggle').onchange = e=> localStorage.setItem('autoCkpt', e.target.checked ? '1' : '0'); $('#autoCkptToggle').checked = localStorage.getItem('autoCkpt')==='1'; // Self‑Update UI $('#suFetch').onclick = async ()=>{ const url = $('#suURL').value.trim(); const saveAs = $('#suSaveAs').value.trim() || ''; const toContainer = $('#suToContainer').checked; try{ const res = await handleSelfUpdateURL(url, saveAs, toContainer); $('#suFetchLog').textContent = JSON.stringify(res, null, 2); }catch(e){ $('#suFetchLog').textContent = 'Error: ' + e.message; } }; $('#suFileGo').onclick = async ()=>{ const f = $('#suFile').files[0]; if(!f){ $('#suFileLog').textContent='Pick a file.'; return; } const saveAs = $('#suFileSaveAs').value.trim() || ''; const toContainer = $('#suFileToContainer').checked; try{ const res = await handleSelfUpdateFile(f, saveAs, toContainer); $('#suFileLog').textContent = JSON.stringify(res, null, 2); }catch(e){ $('#suFileLog').textContent = 'Error: ' + e.message; } }; $('#xpDump').onclick = async ()=>{ try{ const entries = await xpList(); $('#xpLog').textContent = JSON.stringify(entries, null, 2); }catch(e){ $('#xpLog').textContent = 'Error: ' + e.message; } }; // Chat Chat.wire(); // Register a simple service worker for offline (HTTPS/localhost only) try { if ('serviceWorker' in navigator) { const sw = const C='gn-cache-v2';self.addEventListener('install',e=>{e.waitUntil(caches.open(C).then(c=>c.addAll(['./'])));self.skipWaiting();});self.addEventListener('activate',e=>{e.waitUntil(caches.keys().then(keys=>Promise.all(keys.filter(k=>k!==C).map(k=>caches.delete(k)))));self.clients.claim();});self.addEventListener('fetch',e=>{const u=new URL(e.request.url);if(u.origin===location.origin){e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request).then(res=>{const cc=res.clone();caches.open(C).then(c=>c.put(e.request,cc));return res;}).catch(()=>caches.match('./'))));}else{e.respondWith(fetch(e.request).catch(()=>new Response('offline',{status:503})));}});; const blob = new Blob([sw], {type:'text/javascript'}); const url = URL.createObjectURL(blob); navigator.serviceWorker.register(url); } } catch (e) { /* ignore */ } // Maestro UI const canvas = document.getElementById('scoreCanvas'); function showScore(score){ try{ Maestro.drawScore(canvas, score); }catch(e){ /* ignore */ } document.getElementById('mzScoreJSON').value = JSON.stringify(score, null, 2); const code = Maestro.scoreToOneLine(score); document.getElementById('mzOneLine').value = code; const badges = document.getElementById('mzBadges'); badges.innerHTML = ''; const add = (k,v)=>{ const s=document.createElement('span'); s.className='note-badge'; s.textContent = ${k}: ${v}; badges.appendChild(s); }; add('notes', (score.notes||[]).length); if(score.meta?.bytes) add('bytes', score.meta.bytes); if(score.meta?.total_bytes) add('total', score.meta.total_bytes); if(score.meta?.preview_bytes) add('preview', score.meta.preview_bytes); if(score.meta?.sha256) add('sha256', score.meta.sha256.slice(0,12)+'…'); } document.getElementById('mzEncodeText').onclick = async ()=>{ const str = document.getElementById('mzText').value; const sc = await Maestro.encodeText(str); showScore(sc); }; document.getElementById('mzClear').onclick = ()=>{ document.getElementById('mzText').value=''; document.getElementById('mzScoreJSON').value=''; document.getElementById('mzOneLine').value=''; const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); document.getElementById('mzBadges').innerHTML=''; }; document.getElementById('mzEncodeFile').onclick = async ()=>{ const f = document.getElementById('mzFile').files[0]; if(!f){ alert('Pick a file'); return; } const saveAs = document.getElementById('mzSaveAs').value.trim(); const sc = await Maestro.encodeFile(f, saveAs); showScore(sc); }; document.getElementById('mzPlay').onclick = ()=>{ try{ const text = document.getElementById('mzScoreJSON').value.trim(); if(!text){ alert('No score'); return; } const sc = JSON.parse(text); Maestro.playScore(sc); }catch(e){ alert('Bad score'); } }; document.getElementById('mzExportPNG').onclick = ()=> Maestro.exportPNG(canvas); document.getElementById('mzExportScore').onclick = ()=>{ try{ const sc = JSON.parse(document.getElementById('mzScoreJSON').value.trim()); Maestro.exportScore(sc); }catch(e){ alert('No valid score to export'); } }; document.getElementById('mzDecode').onclick = async ()=>{ try{ let scText = document.getElementById('mzScoreJSON').value.trim(); if(!scText){ const line = document.getElementById('mzOneLine').value.trim(); if(!line){ alert('Paste Score JSON or one-line code'); return; } const sc = Maestro.oneLineToScore(line); scText = JSON.stringify(sc); document.getElementById('mzScoreJSON').value = scText; } const sc = JSON.parse(scText); const bytes = Maestro.decodeScoreToBytes(sc); const blob = new Blob([bytes], {type:'application/octet-stream'}); saveBlob((sc.meta?.name||'decoded')+'.bin', blob); document.getElementById('mzOut').textContent = 'Decoded '+bytes.length+' bytes.'; }catch(e){ document.getElementById('mzOut').textContent = 'Error: '+e.message; } }; document.getElementById('mzToText').onclick = async ()=>{ try{ const sc = JSON.parse(document.getElementById('mzScoreJSON').value.trim()); const bytes = Maestro.decodeScoreToBytes(sc); const text = new TextDecoder().decode(bytes); document.getElementById('mzOut').textContent = text; }catch(e){ document.getElementById('mzOut').textContent = 'Error: '+e.message; } }; // PyWeights UI async function refreshPyWModels(){ const ms = await listPyWeightsModels(); const sel = document.getElementById('pywModelSel'); if(!sel) return; sel.innerHTML=''; ms.forEach(m=>{ const o=document.createElement('option'); o.value=m.id; o.textContent = ${m.name} (${m.id.slice(0,8)}); sel.appendChild(o); }); } document.getElementById('pywLoad').onclick = async ()=>{ try{ await pywLoadRuntime(); await refreshPyWModels(); }catch(e){} }; document.getElementById('pywRun').onclick = async ()=>{ const code = document.getElementById('pywCode').value; try{ const out = await pywRun(code); document.getElementById('pywOut').textContent = String(out); }catch(e){ document.getElementById('pywOut').textContent = 'Error: '+e.message; } }; document.getElementById('pywIntegrateFile').onclick = async ()=>{ const f = document.getElementById('pywFile').files[0]; if(!f){ document.getElementById('pywIntegrateLog').textContent='Pick a file.'; return; } const name = f.name.replace(/[^A-Za-z0-9_.-]/g,'_'); const text = await f.text(); const saveAs = document.getElementById('pywSaveAs').value.trim() || ('weights/pyweights/'+name.replace(/\.(txt|py)$/i,'.pyweights')); const toContainer = document.getElementById('pywToContainer').checked; try{ const res = await integratePyWeightsText(name, text, toContainer, saveAs); document.getElementById('pywIntegrateLog').textContent = JSON.stringify(res, null, 2); await refreshPyWModels(); }catch(e){ document.getElementById('pywIntegrateLog').textContent = 'Error: '+e.message; } }; document.getElementById('pywIntegrateURL').onclick = async ()=>{ const url = document.getElementById('pywURL').value.trim(); if(!url){ document.getElementById('pywIntegrateLog').textContent='Enter a URL.'; return; } const saveAs = document.getElementById('pywURLSaveAs').value.trim() || ('weights/pyweights/'+(url.split('/').pop()||'model.pyweights')); const toContainer = document.getElementById('pywURLToContainer').checked; try{ const res = await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const text = await res.text(); const out = await integratePyWeightsText((url.split('/').pop()||'model.pyweights'), text, toContainer, saveAs); document.getElementById('pywIntegrateLog').textContent = JSON.stringify(out, null, 2); await refreshPyWModels(); }catch(e){ document.getElementById('pywIntegrateLog').textContent = 'Error: '+e.message; } }; document.getElementById('pywMaterialize').onclick = async ()=>{ const sel = document.getElementById('pywModelSel'); if(!sel || !sel.value){ document.getElementById('pywMatLog').textContent='Select a model.'; return; } try{ const res = await materializePyWeightsModel(sel.value); document.getElementById('pywMatLog').textContent = Materialized ${res.count} tensors into WGDB for ${res.name}.; }catch(e){ document.getElementById('pywMatLog').textContent = 'Error: '+e.message; } }; document.getElementById('pywExport').onclick = async ()=>{ const sel = document.getElementById('pywModelSel'); if(!sel || !sel.value){ document.getElementById('pywMatLog').textContent='Select a model.'; return; } try{ const r = await exportModelAsPyWeights(sel.value); document.getElementById('pywMatLog').textContent = Exported ${r.count} tensors to .pyweights; }catch(e){ document.getElementById('pywMatLog').textContent = 'Error: '+e.message; } }; // Auto-refresh list when switching tabs (light) document.querySelector('button[data-tab="pyweights"]').addEventListener('click', ()=>{ refreshPyWModels(); }); // Wire Index GGUF button const btnIndexGGUF = document.getElementById('indexGGUF'); if(btnIndexGGUF){ btnIndexGGUF.onclick = async ()=>{ try{ const res = await indexGGUFFolders(); alert(GGUF folders indexed:\nNew: ${res.new}\nExisting: ${res.existed}\nScanned files: ${res.scanned}`); }catch(e){ alert('Index GGUF failed: '+e.message); } }; } // After binding container, automatically index GGUF folders (function patchBindHandler(){ // Find existing bind button handler; if present append auto-index try{ const orig = document.getElementById('upgradeBtn').onclick; document.getElementById('upgradeBtn').onclick = async ()=>{ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); if(orig) try{ await orig(); }catch(){} try{ const res = await indexGGUFFolders(); console.log('Auto-indexed GGUF folders', res); }catch(){} alert('Container bound and GGUF folders indexed.'); }catch(e){ alert('Bind failed: '+e.message); } }; }catch(){ /* if not found, ignore */ } })(); // Ensure GGUF profile is active after bind try{ const orig2 = document.getElementById('upgradeBtn').onclick; document.getElementById('upgradeBtn').onclick = async ()=>{ try{ await Bridge.persist(); const dir = await Bridge.pickContainer(); await Bridge.writeFile('index/objects.json', strToU8(JSON.stringify({created_at: nowISO(), items: []}, null, 2))); try{ await indexGGUFFolders(); }catch(){} await ensureGGUFActive(); if(orig2) try{ await orig2(); }catch(){} try{ await AP.runAssess(); }catch(){} alert('Container bound, GGUF indexed, and active profile set.'); }catch(e){ alert('Bind failed: '+e.message); } }; }catch(){} // Autopilot wiring if(document.getElementById('apAssess')){ document.getElementById('apAssess').onclick = ()=>{ AP.runAssess(); }; } if(document.getElementById('apFix')){ document.getElementById('apFix').onclick = ()=>{ AP.runUpgrade(); }; } // Run a light assess on tab open const apTab = document.querySelector('button[data-tab="autopilot"]'); if(apTab){ apTab.addEventListener('click', ()=>{ AP.runAssess(); }); } // Setup Wiring $('#setupStart')?.addEventListener('click', ()=> startSetupWizard()); $('#imgMake')?.addEventListener('click', async ()=>{ const rel = $('#imgSaveAs').value.trim() || 'images/system_seed.png'; await encodeAppToPNG(rel); }); $('#imgDecode')?.addEventListener('click', ()=> $('#imgFile').click()); $('#imgFile')?.addEventListener('change', async (e)=>{ const f = e.target.files[0]; if(!f) return; try{ await decodePNGToApp(f); }catch(err){ $('#imgLog').textContent = 'Error: '+err.message; } }); // Auto-run setup on first activation if requested try{ const origAutoGlyph = window.autoGlyph; window.autoGlyph = async function(...args){ try{ if(document.getElementById('setupAuto')?.checked){ await startSetupWizard(); } }catch(){} return await origAutoGlyph.apply(this, args); }; }catch(){} // Code tab $('#codeShow')?.addEventListener('click', ()=>{ const src = document.documentElement.outerHTML; $('#codeOut').textContent = src; }); $('#codeDownload')?.addEventListener('click', ()=>{ const src = document.documentElement.outerHTML; const blob = new Blob([src], {type:'text/html'}); saveBlob('glyphNotes_full_source.html', blob); }); $('#codeMap')?.addEventListener('click', ()=>{ // Simple function map by regex const src = document.documentElement.outerHTML; const fn = [...src.matchAll(/function\s+([A-Za-z0-9]+)\s*(/g)].map(m=>m[1]); const arrows = [...src.matchAll(/const\s+([A-Za-z0-9_]+)\s*=\s*(/g)].map(m=>m[1]); const objs = [...src.matchAll(/const\s+([A-Za-z0-9_]+)\s*=\s*{/g)].map(m=>m[1]); const map = {functions: fn, arrows, objects: objs}; $('#codeOut').textContent = JSON.stringify(map, null, 2); }); // Keep header counts in sync (async ()=>{ try{ const prof = await ensureGGUFActive(); if(prof) document.getElementById('hdrGGUFs').textContent = String(prof.tensors.length); document.getElementById('hdrBound').textContent = 'Yes'; // if we got here, engines are usable }catch(){} })(); // Force a permission prompt path: if not bound, show guard quickly (async ()=>{ try{ const st = await Bridge.status?.(); if(!st || !st.bound){ setTimeout(()=>{ try{ showStartupGuard(); }catch(){ /* ignore */ } }, 200); }else{ document.getElementById('hdrBound').textContent = 'Yes'; } }catch(){ setTimeout(()=>{ try{ showStartupGuard(); }catch(){ } }, 200); } })(); // Journal refreshJournal(); });


