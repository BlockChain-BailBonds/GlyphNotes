// ===== Maestro: Glyph Music ===== // Dependencies expected globally elsewhere in glyphNotes: // - nowISO(), strToU8(), u8ToStr(), toB64(u8), fromB64(b64) // - sha256(u8), xpEmit(event, data), Bridge (writeFile/readFile), saveBlob(name, Blob)

const Maestro = (()=>{ // Pitch mapping (16 semitone values for a nibble) const PITCHES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B','C+','C#+','D+','D#+']; // + means next octave const DUR = {s:0.25,e:0.5,q:1,h:2,w:4}; const STAFF = { top: 50, gap: 10 }; // canvas staff settings

function nibbleToNote(n, baseOct=4){ let p = PITCHES[n & 15]; let addOct=0; if(p.includes('+')){ p=p.replace('+',''); addOct=1; } const pitch=p; const octave=baseOct+addOct; return { pitch, octave, dur:'e' }; } function noteToNibble(note){ const name = note.pitch.toUpperCase() + (note.sharp?'#':'') + (note.acc||''); let idx = PITCHES.indexOf(name); if(idx<0){ const base = name.replace(/(\d+)/,''); idx = PITCHES.indexOf(base); if(idx<0) idx = 0; } return idx & 15; } function byteToNotes(b){ return [nibbleToNote((b>>4)&15), nibbleToNote(b&15)]; } function notesToByte(n1,n2){ return ((noteToNibble(n1)&15)<<4) | (noteToNibble(n2)&15); }

function textToU8(str){ return new TextEncoder().encode(str); } function u8ToText(u8){ return new TextDecoder().decode(u8); }

// Score object: {format:'GSM1', notes:[{p:'C',o:4,d:'e'}, ...], meta:{sha256, bytes, preview:true}} function encodeBytesToScore(u8){ const notes=[]; for(let i=0;i<u8.length;i++){ const [n1,n2] = byteToNotes(u8[i]); notes.push({p:n1.pitch,o:n1.octave,d:n1.dur}); notes.push({p:n2.pitch,o:n2.octave,d:n2.dur}); } return { format:'GSM1', notes, meta:{ created_at: nowISO(), bytes: u8.length } }; } function decodeScoreToBytes(score){ const arr = score.notes||[]; const N = arr.length - (arr.length%2); const out = new Uint8Array(N/2); for(let i=0;i<N;i+=2){ const a = {pitch: arr[i].p,   octave: arr[i].o,   dur: arr[i].d||'e'}; const b = {pitch: arr[i+1].p, octave: arr[i+1].o, dur: arr[i+1].d||'e'}; out[i/2] = notesToByte(a,b); } return out; }

// One‑line code (GSM1) const GSM1 = "⟡GSM1"; const GSMF = "⟡/GSM"; function scoreToOneLine(score){ const json = JSON.stringify(score); const u8 = strToU8(json); const b64 = toB64(u8); return ${GSM1}|b64=${b64}|${GSMF}; } function oneLineToScore(line){ const m = line.trim().match(/^⟡GSM1|b64=([A-Za-z0-9+/=]+)|/GSM$/); if(!m) throw new Error('Bad GSM1 line'); const u8 = fromB64(m[1]); return JSON.parse(u8ToStr(u8)); }

// Canvas draw function drawScore(canvas, score){ let staffTopBase = 50; const ctx = canvas.getContext('2d'); const width = canvas.width = canvas.clientWidth; const height = canvas.height = canvas.clientHeight; ctx.clearRect(0,0,width,height); // Staff lines ctx.strokeStyle='#334'; ctx.lineWidth=1; for(let i=0;i<5;i++){ const y = staffTopBase + iSTAFF.gap; ctx.beginPath(); ctx.moveTo(20,y); ctx.lineTo(width-20,y); ctx.stroke(); } // Layout notes const notes = score.notes||[]; const stepX = Math.max(14, (width-40)/Math.max(1, notes.length+2)); let x = 30; for(const n of notes){ const y = yForNote(n); drawNote(ctx, x, y); x += stepX; if(x>width-30){ // new staff stack shiftStaff(); x = 30; } } function yForNote(n){ const map = {'C':-2,'D':-1,'E':0,'F':1,'G':2,'A':3,'B':4}; const base = staffTopBase + 4STAFF.gap; // E4 baseline const offset = map[n.p]!==undefined ? map[n.p] : 0; return base - offsetSTAFF.gap - (n.o-4)3STAFF.gap; } function drawNote(ctx,x,y){ ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.ellipse(x,y,5,7,0,0,Math.PI2); ctx.fill(); ctx.strokeStyle='#ddd'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(x+6,y); ctx.lineTo(x+6,y-25); ctx.stroke(); } function shiftStaff(){ const dy = 140; staffTopBase += dy; // (minor fix from original) for(let i=0;i<5;i++){ const y = staffTopBase + i*STAFF.gap; ctx.beginPath(); ctx.moveTo(20,y); ctx.lineTo(width-20,y); ctx.stroke(); } } }

// Simple playback function playScore(score){ if(!('AudioContext' in window)) return; const ctx = new AudioContext(); const notes = score.notes||[]; let t = ctx.currentTime + 0.05; const tempo = 120; const beat = 60/tempo; for(const n of notes.slice(0,512)){ // cap to prevent very long sessions const freq = pitchToFreq(n.p, n.o||4); const dur = DUR[n.d||'e']||0.5; const osc = ctx.createOscillator(); const g = ctx.createGain(); osc.type='sine'; osc.frequency.value = freq; g.gain.setValueAtTime(0.0001, t); g.gain.linearRampToValueAtTime(0.12, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+durbeat); osc.connect(g).connect(ctx.destination); osc.start(t); osc.stop(t+durbeat+0.02); t += durbeat0.9; } } function pitchToFreq(p, octave){ const A4=440, map={'C':-9,'C#':-8,'D':-7,'D#':-6,'E':-5,'F':-4,'F#':-3,'G':-2,'G#':-1,'A':0,'A#':1,'B':2}; const semi = (octave-4)*12 + (map[p]||0); return A4 * Math.pow(2, semi/12); }

// Encode text async function encodeText(str){ const u8 = textToU8(str); const score = encodeBytesToScore(u8); await xpEmit('maestro.encode.text', {bytes:u8.length}); return score; }

// Encode file (container-backed reference + small preview score) async function encodeFile(file, savePath){ const name = (file.name||'upload.bin').replace(/[^A-Za-z0-9_.-]/g,'_'); const path = savePath || ('scores/'+name+'.gscore'); const buf = new Uint8Array(await file.arrayBuffer()); let location='(embedded)'; try{ await Bridge.writeFile('files/'+name, buf); location = 'container://files/'+name; }catch(e){ /* container not bound; fall back to embedded if small / } const sha = await sha256(buf); const previewLen = Math.min(buf.length, 4096); const score = encodeBytesToScore(buf.slice(0, previewLen)); score.meta = { ...(score.meta||{}), name, sha256: sha, path: location, preview_bytes: previewLen, total_bytes: buf.length }; // Save .gscore into container if possible const text = JSON.stringify(score, null, 2); try{ await Bridge.writeFile(path, strToU8(text)); }catch(e){ / ignore */ } await xpEmit('maestro.encode.file', {name, bytes: buf.length, path: location}); return score; }

// Export helpers function exportPNG(canvas){ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='glyph_score.png'; a.click(); } function exportScore(score){ const blob=new Blob([JSON.stringify(score,null,2)], {type:'application/json'}); saveBlob(score.meta?.name? (score.meta.name+'.gscore') : 'score.gscore', blob); }

return { encodeText, encodeFile, drawScore, playScore, exportPNG, exportScore, scoreToOneLine, oneLineToScore, decodeScoreToBytes }; })();

